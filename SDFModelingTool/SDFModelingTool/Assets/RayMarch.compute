// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#include "UnityCG.cginc"
#include "DistanceFunc.cginc"

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> outputTexture;

//视椎体顶点向量矩阵
float4x4 _FrustumCornersES;
//光线方向
uniform float3 _LightDir;
//raymarch前进最大距离
float _RayMarchDrawDistance;
//摄像机位置
float3 _CameraWS;
//摄像机转世界矩阵
float4x4 _CameraInvViewMatrix;

int _TreeRoot;
int _PostOrderFirst;//后续遍历第一个元素
int _NodeCount;
StructuredBuffer<_Node> _NodesDef;
int _TreeNodeCount;
StructuredBuffer<_TreeNode> _TreeNodesDef;

#define FLOAT_MAX 999999.0;

#define _Width 512.0
#define _Height 288.0

float mapPrimitive(float3 p, _Node primitive) {
	switch (primitive.type) {
	    case NodeType_None:
		    return FLOAT_MAX;
	    case NodeType_Sphere:
		    return sdSphere(p, primitive.param4);
		case NodeType_Box:
			return sdBox(p, float3(primitive.param1, primitive.param2, primitive.param3));
		case NodeType_RoundBox:
			return sdRoundBox(p, float3(primitive.param1, primitive.param2, primitive.param3), primitive.param4);
		case NodeType_Torus:
			return sdTorus(p, float2(primitive.param1, primitive.param2));
		case NodeType_Cylinder:
			return sdCylinder(p, float2(primitive.param1, primitive.param2));
		case NodeType_Cone:
			return sdCone(p, float2(primitive.param1, primitive.param2));
		case NodeType_HexPrism:
			return sdHexPrism(p, float2(primitive.param1, primitive.param2));
		case NodeType_TriPrism:
			return sdTriPrism(p, float2(primitive.param1, primitive.param2));
		case NodeType_Capsule:
			return sdCapsule(p, float3(primitive.param1, primitive.param2, primitive.param3), float3(primitive.param4, primitive.param5, primitive.param6), primitive.param7);
		case NodeType_Triangle:
			return udTriangle(p, float3(primitive.param1, primitive.param2, primitive.param3), float3(primitive.param4, primitive.param5, primitive.param6), float3(primitive.param7, primitive.param8, primitive.param9));
		case NodeType_Quad:
			return udQuad(p, float3(primitive.param1, primitive.param2, primitive.param3), float3(primitive.param4, primitive.param5, primitive.param6), float3(primitive.param7, primitive.param8, primitive.param9), float3(primitive.param10, primitive.param11, primitive.param12));
	}
	return 1;
}

float2 traversal(float3 p) {
	float stack[13]; int top = 0;
	int cur = _PostOrderFirst;
	while (cur != -1) {
		_TreeNode treeNode = _TreeNodesDef[cur];
		_Node node = _NodesDef[treeNode.data];
		if (node.type < NodeType_Union && node.type > NodeType_None) {//is primitive
			//test without matrix mul
			//float d = mapPrimitive(p, node);
			float d = mapPrimitive(mul(node.transform,float4(p,1)).xyz, node);
			stack[top++] = d;
		}
		else if(node.type >= NodeType_Union) {
			float d;
			if (node.type == NodeType_Union) {
				d = opU(stack[top - 2], stack[top - 1]);
				stack[top - 2] = d;
				top--;
			}
			else if (node.type == NodeType_Subtraction) {
				d = opS(stack[top - 2], stack[top - 1]);
				stack[top - 2] = d;
				top--;
			}
			else if (node.type == NodeType_Intersection) {
				d = opI(stack[top - 2], stack[top - 1]);
				stack[top - 2] = d;
				top--;
			}
		}
		cur = treeNode.next;
	}
	return float2(stack[0], top == 1?1:-1);
}

float map(float3 p) {
	return traversal(p);
	///*
	float ret;
	ret = sdSphere(p,1);
	ret = opU(ret, sdBox(float3(p.x-6,p.y,p.z+5), float3(1, 1, 1)));
	ret = opU(ret, sdRoundBox(float3(p.x - 3, p.y, p.z+5), float3(1, 1, 1),0.2f));
	ret = opU(ret, sdTorus(float3(p.x , p.y, p.z+5), float2(1, 1)));
	ret = opU(ret, sdCylinder(float3(p.x + 3, p.y, p.z+5), float2(1, 1)));
	ret = opU(ret, sdHexPrism(float3(p.x + 6, p.y, p.z+5), float2(1, 1)));
	ret = opU(ret, sdTriPrism(float3(p.x - 6, p.y, p.z), float2(1, 1)));
	ret = opU(ret, sdCapsule(float3(p.x - 3, p.y, p.z), float3(0, 0,0),float3(0,1,0),1));
	ret = opU(ret, udTriangle(float3(p.x + 3, p.y, p.z), float3(0, 0,0),float3(0,1,0),float3(1,0,0)));
	ret = opU(ret, udQuad(float3(p.x + 6, p.y, p.z), float3(0, 0,0),float3(1,0,0),float3(1,1,0),float3(0,1,0)));
	return ret;
	//*/
}

float3 calcNormal(in float3 pos)
{
	const float2 eps = float2(0.001, 0.0);
	float3 nor = float3(
		map(pos + eps.xyy).x - map(pos - eps.xyy).x,
		map(pos + eps.yxy).x - map(pos - eps.yxy).x,
		map(pos + eps.yyx).x - map(pos - eps.yyx).x);
	return normalize(nor);
}

// Raymarch along given ray
// ro: ray origin
// rd: ray direction
fixed2 raymarch(float3 ro, float3 rd) {
	fixed2 ret = fixed2(0, 0);
	const int maxstep = 64;
	float t = 0;
	for (int i = 0; i < maxstep; ++i) {
		if (t > _RayMarchDrawDistance) {
			ret = fixed2(0, 0);
			break;
		}
		float3 p = ro + rd * t;
		float d = map(p);
		if (d < 0.001) {
			ret = float2(t, 1);
			break;
		}
		t += d;
	}
	return ret;
}

[numthreads(1, 1, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
	float x = id.x / _Width;
	float y = 1 - id.y / _Height;
	float4 rd = lerp(lerp(_FrustumCornersES[0], _FrustumCornersES[1], x), lerp(_FrustumCornersES[3], _FrustumCornersES[2], x), y);
	rd /= abs(rd.z);
	rd = mul(_CameraInvViewMatrix, rd);
	rd = normalize(rd);
	float3 ro = _CameraWS;
	fixed2 ret = raymarch(ro, rd);
	//outputTexture[id.xy] = float4(ret.x, 0, 0, 1);
	///*
	if (ret.y != 0) {
		float3 p = ro + ret.x*rd;
		float3 n = calcNormal(p);
		float intensity = 0.2 + 0.3* n* _LightDir;
		outputTexture[id.xy] = float4(intensity, intensity, intensity, 1);
	}
	else {
		outputTexture[id.xy] = float4(0.1, 0.1, 0.1, 1);
	}
	//*/
}
