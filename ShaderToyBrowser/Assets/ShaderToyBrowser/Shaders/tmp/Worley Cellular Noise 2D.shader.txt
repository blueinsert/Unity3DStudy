float anim = 0.0;

mat3 m = mat3( 0.00,  0.80,  0.60,
              -0.80,  0.36, -0.48,
              -0.60, -0.48,  0.64 );

//在数组中随机取一个值，满足泊松分布，均值为2.5
const int Poisson_count[256]= int[](
4,3,1,1,1,2,4,2,2,2,5,1,0,2,1,2,2,0,4,3,2,1,2,1,3,2,2,4,2,2,5,1,2,3,
2,2,2,2,2,3,2,4,2,5,3,2,2,2,5,3,3,5,2,1,3,3,4,4,2,3,0,4,2,2,2,1,3,2,
2,2,3,3,3,1,2,0,2,1,1,2,2,2,2,5,3,2,3,2,3,2,2,1,0,2,1,1,2,1,2,2,1,3,
4,2,2,2,5,4,2,4,2,2,5,4,3,2,2,5,4,3,3,3,5,2,2,2,2,2,3,1,1,4,2,1,3,3,
4,3,2,4,3,3,3,4,5,1,4,2,4,3,1,2,3,5,3,2,1,3,1,3,3,3,2,3,1,5,5,4,2,2,
4,1,3,4,1,5,3,3,5,3,4,3,2,2,1,1,1,1,1,2,4,5,4,5,4,2,1,5,1,1,2,3,3,3,
2,5,2,3,3,2,0,2,1,1,4,2,1,3,2,1,2,2,3,2,5,5,3,4,5,5,2,4,4,5,3,2,2,2,
1,4,2,3,3,4,2,5,4,2,4,2,2,2,4,5,3,2);
    
float hash(vec3 p) 
{
    p  = fract( p*0.3183099+.1 );
	p *= 17.0;
    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );
}

float noise( in vec3 x )
{
    vec3 i = floor(x);
    vec3 f = fract(x);
    f = f*f*(3.0-2.0*f);
	
    return mix(mix(mix( hash(i+vec3(0,0,0)), 
                        hash(i+vec3(1,0,0)),f.x),
                   mix( hash(i+vec3(0,1,0)), 
                        hash(i+vec3(1,1,0)),f.x),f.y),
               mix(mix( hash(i+vec3(0,0,1)), 
                        hash(i+vec3(1,0,1)),f.x),
                   mix( hash(i+vec3(0,1,1)), 
                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);
}

vec2 noise22(in vec2 x){
    vec3 p = vec3(x,0.5);
    p.z += anim;
    p *= m;
    float fx = noise(p);
    float fy = noise(p+vec3(1.23,4.56,7.89));
    return vec2(fx,fy);
}

/*
在cellX,cellY指定的晶格中采样，得到最近的四个距离
*/
vec4 AddSamples(int cellX, int cellY, vec2 at, vec4 oldFs, inout vec4 ids){
    vec2 p = vec2(float(cellX),float(cellY));
    vec2 seed = vec2(p.x*1.234+1234.0, p.y*5.678+5678.0);
    float id = seed.x + seed.y;
    //在晶格中产生若干个特征点，个数在泊松分布表中随机得到
    int count = Poisson_count[int(fract(seed.x+seed.y)*256.0)];
    for(int i = 0; i < count; i++){
        vec2 diff = noise22(seed);
        //偏移种子，用以产生下一个不同的偏移
        seed.x = seed.x*1.366+0.123;
        seed.y = seed.y*2.4745687+7.73246;
        
        vec2 featurePoint = p + diff;
        
        float d = length(featurePoint - at);
        d*=d;
        if(d<oldFs.x){
            oldFs.yzw = oldFs.xyz;oldFs.x = d;
            ids.yzw = ids.yzw;ids.x = id;
        }else if(d<oldFs.y){
            oldFs.zw = oldFs.yz;oldFs.y = d;
            ids.zw = ids.yz;ids.y = id;
        }else if(d<oldFs.z){
            oldFs.w = oldFs.z;oldFs.z = d;
            ids.w = ids.z;ids.z = id;
        }else if(d<oldFs.w){
            oldFs.w = d;
            ids.w = id;
        }
        
    }
    return oldFs;
}

/*
2d Worley细胞噪声
输入：位置
输出：从小到大排序的距离最近的四个特征点的距离
*/
vec4 cellularNoise2D(vec2 at, inout vec4 ids){
    vec2 int_at = floor(at);
    int int_at_x = int(int_at.x);
    int int_at_y = int(int_at.y);
    vec4 fs = vec4(9999999.0,9999999.0,9999999.0,9999999.0);
    fs = AddSamples(int_at_x,int_at_y,at,fs,ids);
    float dx1 = at.x - int_at.x;
    float dy1 = at.y - int_at.y;
    float dx2 = (1.0-dx1)*(1.0-dx1);
    float dy2 = (1.0-dy1)*(1.0-dy1);
    dx1 *= dx1;
    dy1 *= dy1;
    int max_order = 4;
    //判断是否得到了最近的四个距离，如果是的话，不必在相邻晶格进行采样
    if(dx1<fs[max_order-1])//左
        fs = AddSamples(int_at_x-1,int_at_y,at,fs,ids);
    if(dy1 < fs[max_order-1])//下
        fs = AddSamples(int_at_x,int_at_y-1,at,fs,ids);
    if(dx1+dy1 < fs[max_order-1])//左下
        fs = AddSamples(int_at_x-1,int_at_y-1,at,fs,ids);
    if(dx2 < fs[max_order-1])//右
        fs = AddSamples(int_at_x+1,int_at_y,at,fs,ids);
    if(dy2 < fs[max_order-1])//上
        fs = AddSamples(int_at_x,int_at_y+1,at,fs,ids);
    if(dx2+dy2 < fs[max_order-1])//右上
        fs = AddSamples(int_at_x+1,int_at_y+1,at,fs,ids);
    if(dx1+dy2 < fs[max_order-1])//左上
        fs = AddSamples(int_at_x-1,int_at_y+1,at,fs,ids);
    if(dx2+dy1 < fs[max_order-1])//右下
        fs = AddSamples(int_at_x+1,int_at_y-1,at,fs,ids);
    return fs;
}


vec4 fractalCellularNoise2D(vec2 at) {
	vec4 m = vec4(0.0, 0.0, 0.0, 0.0);
	float f = 1.0;
	for (int i = 0; i < 5; i++) {
        vec4 ids;
		m += cellularNoise2D(at*f,ids) / f;
		f *= 2.17;
	}
	return m;
}

vec3 cellId2Color(float id)
{
	return texture(iChannel0,vec2(mod(id,64.)/64., mod(floor(id/64.),64.)/64.)).rgb;
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    anim = 0.5*(2.*iTime + .5*sin(1.*iTime+10.0));

    vec2 p = fragCoord/iResolution.y;
    vec2 at = p*4.0;
    float anim2 = iTime*0.2;
    float scanLineX = fract(anim2);
    int demo = int(floor(mod(anim2,11.0)));//linear combination
    float x = fragCoord.x/iResolution.x;
    if(x > scanLineX){
        demo = demo - 1;
        if(demo<0)
            demo = 10;
    }
    vec3 col = vec3(0.0,0.0,0.0);
    
        vec4 fs = fractalCellularNoise2D(at);fs = sqrt(fs);
        col = vec3(fs.x);
   
    
    col *= smoothstep(0.0,0.01,abs(x-scanLineX));
    fragColor = vec4(col.xyz, 1.0);
}