#define AA 2

float anim = 0.0;

mat3 m = mat3( 0.00,  0.80,  0.60,
              -0.80,  0.36, -0.48,
              -0.60, -0.48,  0.64 );

//在数组中随机取一个值，满足泊松分布，均值为2.5
const int Poisson_count[256]= int[](
4,3,1,1,1,2,4,2,2,2,5,1,0,2,1,2,2,0,4,3,2,1,2,1,3,2,2,4,2,2,5,1,2,3,
2,2,2,2,2,3,2,4,2,5,3,2,2,2,5,3,3,5,2,1,3,3,4,4,2,3,0,4,2,2,2,1,3,2,
2,2,3,3,3,1,2,0,2,1,1,2,2,2,2,5,3,2,3,2,3,2,2,1,0,2,1,1,2,1,2,2,1,3,
4,2,2,2,5,4,2,4,2,2,5,4,3,2,2,5,4,3,3,3,5,2,2,2,2,2,3,1,1,4,2,1,3,3,
4,3,2,4,3,3,3,4,5,1,4,2,4,3,1,2,3,5,3,2,1,3,1,3,3,3,2,3,1,5,5,4,2,2,
4,1,3,4,1,5,3,3,5,3,4,3,2,2,1,1,1,1,1,2,4,5,4,5,4,2,1,5,1,1,2,3,3,3,
2,5,2,3,3,2,0,2,1,1,4,2,1,3,2,1,2,2,3,2,5,5,3,4,5,5,2,4,4,5,3,2,2,2,
1,4,2,3,3,4,2,5,4,2,4,2,2,2,4,5,3,2);
    
float hash(vec3 p) 
{
    p  = fract( p*0.3183099+.1 );
	p *= 17.0;
    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );
}

float noise( in vec3 x )
{
    vec3 i = floor(x);
    vec3 f = fract(x);
    f = f*f*(3.0-2.0*f);
	
    return mix(mix(mix( hash(i+vec3(0,0,0)), 
                        hash(i+vec3(1,0,0)),f.x),
                   mix( hash(i+vec3(0,1,0)), 
                        hash(i+vec3(1,1,0)),f.x),f.y),
               mix(mix( hash(i+vec3(0,0,1)), 
                        hash(i+vec3(1,0,1)),f.x),
                   mix( hash(i+vec3(0,1,1)), 
                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);
}

vec2 noise22(in vec2 x){
    vec3 p = vec3(x,0.5);
    p.z += anim;
    p *= m;
    float fx = noise(p);
    float fy = noise(p+vec3(1.23,4.56,7.89));
    return vec2(fx,fy);
}

/*
在cellX,cellY指定的晶格中采样，得到最近的四个距离
*/
vec4 AddSamples(int cellX, int cellY, vec2 at, vec4 oldFs, inout vec4 ids){
    vec2 p = vec2(float(cellX),float(cellY));
    vec2 seed = vec2(p.x*1.234+1234.0, p.y*5.678+5678.0);
    float id = seed.x + seed.y;
    //在晶格中产生若干个特征点，个数在泊松分布表中随机得到
    int count = Poisson_count[int(fract(seed.x+seed.y)*256.0)];
    for(int i = 0; i < count; i++){
        vec2 diff = noise22(seed);
        //偏移种子，用以产生下一个不同的偏移
        seed.x = seed.x*1.366+0.123;
        seed.y = seed.y*2.4745687+7.73246;
        
        vec2 featurePoint = p + diff;
        
        float d = length(featurePoint - at);
        d*=d;
        if(d<oldFs.x){
            oldFs.yzw = oldFs.xyz;oldFs.x = d;
            ids.yzw = ids.yzw;ids.x = id;
        }else if(d<oldFs.y){
            oldFs.zw = oldFs.yz;oldFs.y = d;
            ids.zw = ids.yz;ids.y = id;
        }else if(d<oldFs.z){
            oldFs.w = oldFs.z;oldFs.z = d;
            ids.w = ids.z;ids.z = id;
        }else if(d<oldFs.w){
            oldFs.w = d;
            ids.w = id;
        }
        
    }
    return oldFs;
}

/*
2d Worley细胞噪声
输入：位置
输出：从小到大排序的距离最近的四个特征点的距离
*/
vec4 cellularNoise2D(vec2 at, inout vec4 ids){
    vec2 int_at = floor(at);
    int int_at_x = int(int_at.x);
    int int_at_y = int(int_at.y);
    vec4 fs = vec4(9999999.0,9999999.0,9999999.0,9999999.0);
    fs = AddSamples(int_at_x,int_at_y,at,fs,ids);
    float dx1 = at.x - int_at.x;
    float dy1 = at.y - int_at.y;
    float dx2 = (1.0-dx1)*(1.0-dx1);
    float dy2 = (1.0-dy1)*(1.0-dy1);
    dx1 *= dx1;
    dy1 *= dy1;
    int max_order = 4;
    //判断是否得到了最近的四个距离，如果是的话，不必在相邻晶格进行采样
    if(dx1<fs[max_order-1])//左
        fs = AddSamples(int_at_x-1,int_at_y,at,fs,ids);
    if(dy1 < fs[max_order-1])//下
        fs = AddSamples(int_at_x,int_at_y-1,at,fs,ids);
    if(dx1+dy1 < fs[max_order-1])//左下
        fs = AddSamples(int_at_x-1,int_at_y-1,at,fs,ids);
    if(dx2 < fs[max_order-1])//右
        fs = AddSamples(int_at_x+1,int_at_y,at,fs,ids);
    if(dy2 < fs[max_order-1])//上
        fs = AddSamples(int_at_x,int_at_y+1,at,fs,ids);
    if(dx2+dy2 < fs[max_order-1])//右上
        fs = AddSamples(int_at_x+1,int_at_y+1,at,fs,ids);
    if(dx1+dy2 < fs[max_order-1])//左上
        fs = AddSamples(int_at_x-1,int_at_y+1,at,fs,ids);
    if(dx2+dy1 < fs[max_order-1])//右下
        fs = AddSamples(int_at_x+1,int_at_y-1,at,fs,ids);
    return fs;
}


vec4 fractalCellularNoise2D(vec2 at) {
	vec4 m = vec4(0.0, 0.0, 0.0, 0.0);
	float f = 1.0;
	for (int i = 0; i < 3; i++) {
        vec4 ids;
		m += cellularNoise2D(at*f,ids) / f;
		f *= 2.17;
	}
	return m;
}

float dot2( vec3 v ) { return dot(v,v); }
float udQuad( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d )
{
  vec3 ba = b - a; vec3 pa = p - a;
  vec3 cb = c - b; vec3 pb = p - b;
  vec3 dc = d - c; vec3 pc = p - c;
  vec3 ad = a - d; vec3 pd = p - d;
  vec3 nor = cross( ba, ad );

  return sqrt(
    (sign(dot(cross(ba,nor),pa)) +
     sign(dot(cross(cb,nor),pb)) +
     sign(dot(cross(dc,nor),pc)) +
     sign(dot(cross(ad,nor),pd))<3.0)
     ?
     min( min( min(
     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),
     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),
     dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),
     dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) )
     :
     dot(nor,pa)*dot(nor,pa)/dot2(nor) );
}

vec2 opU( vec2 d1, vec2 d2 )
{
	return (d1.x<d2.x) ? d1 : d2;
}

vec2 map( in vec3 pos )
{
    vec2 res = vec2(1e10, 0.0);
    float hwidth = 3.0;
    res = opU(res, vec2(udQuad(pos, vec3(-hwidth,0.0,-hwidth), vec3(hwidth,0.0,-hwidth), vec3(hwidth,0.0,hwidth), vec3(-hwidth,0.0,hwidth)),1));
        
    return res;
}

float getBumpMap(in vec2 uv){
    uv *= 1.1;
    return fractalCellularNoise2D(uv).x;
}

vec2 getPerturbationVector(in vec2 uv)
{
    vec2 size = vec2(.00001,0.0);
    float  perturbationU = (getBumpMap(uv+size.xy) - getBumpMap(uv-size.xy))/(2.0*size.x);
    float  perturbationV = (getBumpMap(uv+size.yx) - getBumpMap(uv-size.yx))/(2.0*size.x);
    return vec2(perturbationU,perturbationV);
}

vec3 getNormal(in vec3 pos)
{
    vec3 nW = normalize(vec3(0.0,1.0,0.0));
    vec3 uW = normalize(vec3(1.0,0.0,0.0));
    vec3 vW = normalize(vec3(0.0,0.0,1.0));
    
    vec2 uv = pos.xz;
    vec2 perturbation = getPerturbationVector(uv);
    vec3 n = nW + uW*perturbation.x + vW*perturbation.y;
    n = normalize(n);
    //n =  normalize(vec3(dot(n,uW),dot(n,vW),dot(n,nW)));
    return n;
}

vec2 castRay( in vec3 ro, in vec3 rd )
{
    vec2 res = vec2(-1.0,-1.0);

    float tmin = 1.0;
    float tmax = 20.0;

    float t = tmin;
    for( int i = 0; i < 70 && t < tmax; i++ )
    {
        vec2 h = map( ro+rd*t );
        if( abs(h.x)<(0.0001*t) )
        { 
            res = vec2(t,h.y); 
            break;
        }
        t += h.x;
    }
    
    return res;
}


const vec3 LightPos = vec3(5,5,5);
const vec3 LightColor = vec3(1,1,1);
const vec3 Ambient = vec3(0.4,0.4,0.4);

vec3 lambert(in vec3 objColor, in vec3 pos, in vec3 normal, in vec3 view)
{
    float ka = 0.01;
    float kd = 0.5;
    //float ks = 0.3;
    float shininess = 8.0;
    vec3 l = normalize(LightPos - pos);
    vec3 ref = reflect(-l, normal);
    vec3 a = ka * Ambient * objColor;
    vec3 d = kd * LightColor * clamp(dot(normal, l),0.0,1.0) * objColor;
    //vec3 s = ks * LightColor * pow(dot(ref, view), shininess) * objColor;
    return a + d;// + s;
}   


vec3 render(in vec3 ro, in vec3 rd)
{
    vec2 res = castRay(ro,rd);
    float t = res.x;
	float m = res.y; 
    vec3 pos = ro + t * rd;
    vec3 col = vec3(0,0,0); 
    if(m <= -1.0)//skyBox
    {
        col = vec3(0.3,0.8,1.0);
    } else{
        vec3 n = getNormal(pos);
        col = lambert(vec3(1,0.8,0.2), pos, n, -rd);
		//col = vec3(getBumpMap(pos.xz));
    }
    return col;
}

mat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)
{
    vec3 w = normalize(targetPos - cameraPos);
    vec3 up = vec3(0,1,0);
    vec3 u = normalize(cross(w, up));
    vec3 v = normalize(cross(u,w));
    return mat3(u,v,w);
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    anim = 0.5*(2.*iTime + .5*sin(1.*iTime+10.0));
	
    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);
    float time = iTime * 0.1;
    vec3 cameraPos = vec3((3.0 + -3.0*mousePos.y) * cos(time + 6.0*mousePos.x), 4.0 , (3.0 + -3.0*mousePos.y) * sin(time + + 6.0*mousePos.x));
    vec3 lookAtPos = vec3(0,0.0,0);
    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);
    
    
    vec3 sum = vec3(0.0);
    for(int i = 0;i<AA;i++){
        for(int j = 0;j<AA;j++){
             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;
             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;
             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));
             vec3 col = render(cameraPos, rayDir);
             col = pow( col, vec3(0.4545) );
             sum += col;
        }
    }
    
    sum /= float(AA*AA);

    fragColor = vec4(sum, 1);
    
}