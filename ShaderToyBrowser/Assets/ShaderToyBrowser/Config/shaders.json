{"userName":"bluebean","date":"2019-12-29T07:36:08.971Z","numShaders":31,"shaders":[{"ver":"0.1","info":{"id":"tlt3Rs","date":"0","viewed":0,"name":"Antialiase Planetary Ring","description":"索引反锯齿行星环","likes":0,"published":"Private","tags":["math","indexantialiase"]},"renderpass":[{"code":"#define TableSize 256\n\nint initialized = 0;\nvec3 integralTable[TableSize];\nvec3 table[TableSize];\n\nfloat xPixelWidth;\nfloat yPixelWidth;\n\n//作为基础的随机函数\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//基于晶格的值噪声\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve 平滑曲线\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\n\n//基于值噪声的分形噪声\nfloat fractal_noise(in vec2 p)\n{\n\tp *= 5.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tfloat f  = 0.5000*value_noise(p); p = m*p;\n\tf += 0.2500*value_noise(p); p = m*p;\n\tf += 0.1250*value_noise(p); p = m*p;\n\tf += 0.0625*value_noise(p); p = m*p;\n    \n    return f;\n}\n\nvoid makeColorTable(float inner,float outer,float transition,float low,float high)\n{\n    if(initialized==1){\n        return;\n    }\n    float R;\n    float A;\n    float F1,F2,F3;\n    \n    for(int i = 0;i<TableSize;i++){\n        R = outer*(float(i)+0.5)/(float(TableSize)-1.0);//[0,outer]\n        if(R<=inner)\n            A = 0.0;\n        else if(R<inner+transition){\n            A = (R-inner)/transition;\n            A *= A*(3.0-2.0*A);\n        }else if(R>outer-transition){\n            A = (outer-R)/transition;\n            A *= A*(3.0-2.0*A);\n        }else\n            A = 1.0;\n        F1 = fractal_noise(vec2(R,0.0));\n        F2 = fractal_noise(vec2(R,1.234));\n        F3 = fractal_noise(vec2(R,5.678));\n        F1 = smoothstep(low,high,F1);\n        F2 = smoothstep(low,high,F2);\n        F3 = smoothstep(low,high,F3);\n        table[i] = vec3(F1,F2,F3)*A;\n        integralTable[i] = (i==0?vec3(0.0):integralTable[i-1]) + table[i];\n    }\n    initialized = 1;\n}\n\nvec3 ringColorAntiliase(vec2 pos,float spotSize,float inner,float outer){\n    float R0,R1;\n    int I0,I1;\n    float weight;\n    R0 = sqrt(pos.x*pos.x+pos.y*pos.y)-0.5*spotSize;\n    R1 = R0+spotSize;\n    R0 = max(R0,0.0);\n    I0 = int(R0*float(TableSize-1)/outer);\n    I1 = int(R1*float(TableSize-1)/outer);\n    if(I0==I1)\n        I1++;\n    if(I0>=TableSize)\n        return vec3(0.0);\n    if(I1>=TableSize){\n        weight = float(TableSize-I0)/float(I1-I0);\n        I1 = TableSize - 1;\n    }else\n        weight = 1.0;\n    return weight*(integralTable[I1]-integralTable[I0])/float(I1-I0);\n}\n\nvec3 ringColor(vec2 pos, float inner,float outer){\n    \n    float R;\n    int I;\n    R = sqrt(pos.x*pos.x+pos.y*pos.y);\n  \n    I = int(R*float(TableSize-1)/outer);\n   \n    return table[I];\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    vec2 mouse = 2.0*(iMouse.xy / iResolution.xy - vec2(0.5,0.5));\n    \n    float scale = pow(10.0,mouse.y);\n    vec2 pos = (p+vec2(mouse.x*10.0,0.0))*scale;\n    \n    xPixelWidth = yPixelWidth = 2.0/iResolution.y*scale;\n    float spotSize = sqrt(xPixelWidth*xPixelWidth + yPixelWidth*yPixelWidth);\n    \n    float inner = 4.0;\n    float outer = 9.0;\n    float transition = 0.5;\n    float low = 0.1;\n    float high = 0.9;\n    vec3 col;\n    col = vec3(float(initialized));\n    makeColorTable(inner,outer,transition,low,high);\n    if(p.y>0.0){\n        //col = ringColor(pos,inner,outer);\n    }else{\n        //col = ringColorAntiliase(pos,spotSize,inner,outer);\n    }\n    col *= smoothstep(0.0,0.01,abs(p.y-0.0));\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"wll3zf","date":"0","viewed":0,"name":"Basic Lambert Box","description":"Basic Lambert Box","likes":0,"published":"Private","tags":["basic"]},"renderpass":[{"code":"const float NearClipPlaneDist = 2.0;\nconst vec3 LightPos = vec3(5,5,5);\nconst vec3 LightColor = vec3(1,1,1);\nconst vec3 Ambient = vec3(0.1,0.1,0.1);\nconst int PrimitiveType = 1;\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n    if(PrimitiveType == 0)\n    {\n        res = opU(res, vec2(sdBox(pos, vec3(1,1,1)),1));\n    }else if(PrimitiveType == 1)\n    {\n        res = opU(res, vec2(sdSphere(pos + vec3(0,-1,0), 1.0),1));\n    }\n    res = opU(res, vec2(sdPlane(pos),0));\n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n#if 1\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nvec3 lambert(in vec3 pos, in vec3 normal, in vec3 view)\n{\n    float ka = 0.5;\n    float kd = 1.0;\n    float ks = 0.5;\n    float shininess = 2.0;\n    vec3 objCol = vec3(1,0.8,0.2);\n    vec3 l = normalize(LightPos - pos);\n    vec3 ref = reflect(-l, normal);\n    vec3 a = ka * Ambient * objCol;\n    vec3 d = kd * LightColor * dot(normal, l) * objCol;\n    vec3 s = ks * LightColor * pow(dot(ref, view), shininess) * objCol;\n    return a + d + s;\n}   \n\nvec3 sampleEnvironment(in vec3 rd)\n{\n    return texture(iChannel0, rd).rgb;\n}   \n              \nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 normal = vec3(0,0,0);\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        //col = sampleEnvironment(rd);\n        col = Ambient;\n    } else if(m == 0.0){//floor\n         float f = checkersGradBox( 1.0*pos.xz );\n         col = 0.3 + f*vec3(0.1);\n    }else {\n        normal = calcNormal( pos );\n        col = lambert(pos, normal, -rd);\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(5.0 * cos(time + 6.0*mousePos.x), 1.0 + 2.0*mousePos.y, 5.0 * sin(time + + 6.0*mousePos.x));\n    \n    vec3 lookAtPos = vec3(0,0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    vec2 pixelPosInCameraCoor = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    vec3 rayDir = viewMatrix * normalize(vec3(pixelPosInCameraCoor.xy, NearClipPlaneDist));\n    vec3 col = render(cameraPos, rayDir);\n    \n    col = pow( col, vec3(0.4545) );\n    // Output to screen\n    fragColor = vec4(col.xyz, 1);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"3l3GWS","date":"0","viewed":0,"name":"Bump Map","description":"凹凸贴图","likes":0,"published":"Private","tags":["noise","bump"]},"renderpass":[{"code":"#define AA 2\n\n#define SpherePos vec3(0.0,0.0,0.0)\n#define SphereRadius 2.0\n\n//作为基础的随机函数\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//基于晶格的值噪声\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve 平滑曲线\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\n\n//基于值噪声的分形噪声\nfloat fractal_noise(in vec2 p)\n{\n\tp *= 5.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tfloat f  = 0.5000*value_noise(p); p = m*p;\n\tf += 0.2500*value_noise(p); p = m*p;\n\tf += 0.1250*value_noise(p); p = m*p;\n\tf += 0.0625*value_noise(p); p = m*p;\n    \n    return f;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos - SpherePos, SphereRadius),1));\n        \n    return res;\n}\n\nvec2 getSphereUV(in vec3 pos)\n{\n    vec3 posLocal = pos - SpherePos;\n    //经纬角度\n    float longitudeAngle = atan(posLocal.x/posLocal.z)/3.1415926*180.0;\n    float latitudeAngle = acos(posLocal.y/SphereRadius)/3.1415926*180.0;\n    \n    return vec2(longitudeAngle,latitudeAngle);\n}\n\nfloat getBumpMap(in vec2 uv){\n    uv *= 0.0081;\n    return fractal_noise(uv)*25.23;\n}\n\nvec2 getPerturbationVector(in vec2 uv)\n{\n    vec2 size = vec2(.00001,0.0);\n    float  perturbationU = (getBumpMap(uv+size.xy) - getBumpMap(uv-size.xy))/(2.0*size.x);\n    float  perturbationV = (getBumpMap(uv+size.yx) - getBumpMap(uv-size.yx))/(2.0*size.x);\n    return vec2(perturbationU,perturbationV);\n}\n\nvec3 getSphereNormal(in vec3 pos)\n{\n    vec3 posLocal = pos - SpherePos;\n    \n    vec3 nW = normalize(posLocal);\n    vec3 uW = normalize(vec3(-nW.z,0.0,nW.x));\n    vec3 vW = normalize(cross(nW,uW));\n    \n    vec2 uv = getSphereUV(pos);\n    vec2 perturbation = getPerturbationVector(uv);\n    vec3 n = nW + uW*perturbation.x + vW*perturbation.y;\n    n = normalize(n);\n    //n =  normalize(vec3(dot(n,uW),dot(n,vW),dot(n,nW)));\n    return n;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\n\nconst vec3 LightPos = vec3(5,5,5);\nconst vec3 LightColor = vec3(1,1,1);\nconst vec3 Ambient = vec3(0.4,0.4,0.4);\n\nvec3 lambert(in vec3 objColor, in vec3 pos, in vec3 normal, in vec3 view)\n{\n    float ka = 0.01;\n    float kd = 0.5;\n    //float ks = 0.3;\n    float shininess = 8.0;\n    vec3 l = normalize(LightPos - pos);\n    vec3 ref = reflect(-l, normal);\n    vec3 a = ka * Ambient * objColor;\n    vec3 d = kd * LightColor * clamp(dot(normal, l),0.0,1.0) * objColor;\n    //vec3 s = ks * LightColor * pow(dot(ref, view), shininess) * objColor;\n    return a + d;// + s;\n}   \n\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.3,0.8,1.0);\n    } else{\n        vec3 n = getSphereNormal(pos);\n        col = lambert(vec3(1,0.8,0.2), pos, n, -rd);\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3((3.0 + -3.0*mousePos.y) * cos(time + 6.0*mousePos.x), 2.0 , (3.0 + -3.0*mousePos.y) * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0.0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"wt33D2","date":"0","viewed":0,"name":"Bump map2","description":"Bump map2","likes":0,"published":"Private","tags":["math","bump"]},"renderpass":[{"code":"#define AA 2\n\nfloat anim = 0.0;\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\n//在数组中随机取一个值，满足泊松分布，均值为2.5\nconst int Poisson_count[256]= int[](\n4,3,1,1,1,2,4,2,2,2,5,1,0,2,1,2,2,0,4,3,2,1,2,1,3,2,2,4,2,2,5,1,2,3,\n2,2,2,2,2,3,2,4,2,5,3,2,2,2,5,3,3,5,2,1,3,3,4,4,2,3,0,4,2,2,2,1,3,2,\n2,2,3,3,3,1,2,0,2,1,1,2,2,2,2,5,3,2,3,2,3,2,2,1,0,2,1,1,2,1,2,2,1,3,\n4,2,2,2,5,4,2,4,2,2,5,4,3,2,2,5,4,3,3,3,5,2,2,2,2,2,3,1,1,4,2,1,3,3,\n4,3,2,4,3,3,3,4,5,1,4,2,4,3,1,2,3,5,3,2,1,3,1,3,3,3,2,3,1,5,5,4,2,2,\n4,1,3,4,1,5,3,3,5,3,4,3,2,2,1,1,1,1,1,2,4,5,4,5,4,2,1,5,1,1,2,3,3,3,\n2,5,2,3,3,2,0,2,1,1,4,2,1,3,2,1,2,2,3,2,5,5,3,4,5,5,2,4,4,5,3,2,2,2,\n1,4,2,3,3,4,2,5,4,2,4,2,2,2,4,5,3,2);\n    \nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nvec2 noise22(in vec2 x){\n    vec3 p = vec3(x,0.5);\n    p.z += anim;\n    p *= m;\n    float fx = noise(p);\n    float fy = noise(p+vec3(1.23,4.56,7.89));\n    return vec2(fx,fy);\n}\n\n/*\n在cellX,cellY指定的晶格中采样，得到最近的四个距离\n*/\nvec4 AddSamples(int cellX, int cellY, vec2 at, vec4 oldFs, inout vec4 ids){\n    vec2 p = vec2(float(cellX),float(cellY));\n    vec2 seed = vec2(p.x*1.234+1234.0, p.y*5.678+5678.0);\n    float id = seed.x + seed.y;\n    //在晶格中产生若干个特征点，个数在泊松分布表中随机得到\n    int count = Poisson_count[int(fract(seed.x+seed.y)*256.0)];\n    for(int i = 0; i < count; i++){\n        vec2 diff = noise22(seed);\n        //偏移种子，用以产生下一个不同的偏移\n        seed.x = seed.x*1.366+0.123;\n        seed.y = seed.y*2.4745687+7.73246;\n        \n        vec2 featurePoint = p + diff;\n        \n        float d = length(featurePoint - at);\n        d*=d;\n        if(d<oldFs.x){\n            oldFs.yzw = oldFs.xyz;oldFs.x = d;\n            ids.yzw = ids.yzw;ids.x = id;\n        }else if(d<oldFs.y){\n            oldFs.zw = oldFs.yz;oldFs.y = d;\n            ids.zw = ids.yz;ids.y = id;\n        }else if(d<oldFs.z){\n            oldFs.w = oldFs.z;oldFs.z = d;\n            ids.w = ids.z;ids.z = id;\n        }else if(d<oldFs.w){\n            oldFs.w = d;\n            ids.w = id;\n        }\n        \n    }\n    return oldFs;\n}\n\n/*\n2d Worley细胞噪声\n输入：位置\n输出：从小到大排序的距离最近的四个特征点的距离\n*/\nvec4 cellularNoise2D(vec2 at, inout vec4 ids){\n    vec2 int_at = floor(at);\n    int int_at_x = int(int_at.x);\n    int int_at_y = int(int_at.y);\n    vec4 fs = vec4(9999999.0,9999999.0,9999999.0,9999999.0);\n    fs = AddSamples(int_at_x,int_at_y,at,fs,ids);\n    float dx1 = at.x - int_at.x;\n    float dy1 = at.y - int_at.y;\n    float dx2 = (1.0-dx1)*(1.0-dx1);\n    float dy2 = (1.0-dy1)*(1.0-dy1);\n    dx1 *= dx1;\n    dy1 *= dy1;\n    int max_order = 4;\n    //判断是否得到了最近的四个距离，如果是的话，不必在相邻晶格进行采样\n    if(dx1<fs[max_order-1])//左\n        fs = AddSamples(int_at_x-1,int_at_y,at,fs,ids);\n    if(dy1 < fs[max_order-1])//下\n        fs = AddSamples(int_at_x,int_at_y-1,at,fs,ids);\n    if(dx1+dy1 < fs[max_order-1])//左下\n        fs = AddSamples(int_at_x-1,int_at_y-1,at,fs,ids);\n    if(dx2 < fs[max_order-1])//右\n        fs = AddSamples(int_at_x+1,int_at_y,at,fs,ids);\n    if(dy2 < fs[max_order-1])//上\n        fs = AddSamples(int_at_x,int_at_y+1,at,fs,ids);\n    if(dx2+dy2 < fs[max_order-1])//右上\n        fs = AddSamples(int_at_x+1,int_at_y+1,at,fs,ids);\n    if(dx1+dy2 < fs[max_order-1])//左上\n        fs = AddSamples(int_at_x-1,int_at_y+1,at,fs,ids);\n    if(dx2+dy1 < fs[max_order-1])//右下\n        fs = AddSamples(int_at_x+1,int_at_y-1,at,fs,ids);\n    return fs;\n}\n\n\nvec4 fractalCellularNoise2D(vec2 at) {\n\tvec4 m = vec4(0.0, 0.0, 0.0, 0.0);\n\tfloat f = 1.0;\n\tfor (int i = 0; i < 3; i++) {\n        vec4 ids;\n\t\tm += cellularNoise2D(at*f,ids) / f;\n\t\tf *= 2.17;\n\t}\n\treturn m;\n}\n\nfloat dot2( vec3 v ) { return dot(v,v); }\nfloat udQuad( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 dc = d - c; vec3 pc = p - c;\n  vec3 ad = a - d; vec3 pd = p - d;\n  vec3 nor = cross( ba, ad );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(dc,nor),pc)) +\n     sign(dot(cross(ad,nor),pd))<3.0)\n     ?\n     min( min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n     dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n    float hwidth = 3.0;\n    res = opU(res, vec2(udQuad(pos, vec3(-hwidth,0.0,-hwidth), vec3(hwidth,0.0,-hwidth), vec3(hwidth,0.0,hwidth), vec3(-hwidth,0.0,hwidth)),1));\n        \n    return res;\n}\n\nfloat getBumpMap(in vec2 uv){\n    uv *= 1.1;\n    return fractalCellularNoise2D(uv).x;\n}\n\nvec2 getPerturbationVector(in vec2 uv)\n{\n    vec2 size = vec2(.00001,0.0);\n    float  perturbationU = (getBumpMap(uv+size.xy) - getBumpMap(uv-size.xy))/(2.0*size.x);\n    float  perturbationV = (getBumpMap(uv+size.yx) - getBumpMap(uv-size.yx))/(2.0*size.x);\n    return vec2(perturbationU,perturbationV);\n}\n\nvec3 getNormal(in vec3 pos)\n{\n    vec3 nW = normalize(vec3(0.0,1.0,0.0));\n    vec3 uW = normalize(vec3(1.0,0.0,0.0));\n    vec3 vW = normalize(vec3(0.0,0.0,1.0));\n    \n    vec2 uv = pos.xz;\n    vec2 perturbation = getPerturbationVector(uv);\n    vec3 n = nW + uW*perturbation.x + vW*perturbation.y;\n    n = normalize(n);\n    //n =  normalize(vec3(dot(n,uW),dot(n,vW),dot(n,nW)));\n    return n;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\n\nconst vec3 LightPos = vec3(5,5,5);\nconst vec3 LightColor = vec3(1,1,1);\nconst vec3 Ambient = vec3(0.4,0.4,0.4);\n\nvec3 lambert(in vec3 objColor, in vec3 pos, in vec3 normal, in vec3 view)\n{\n    float ka = 0.01;\n    float kd = 0.5;\n    //float ks = 0.3;\n    float shininess = 8.0;\n    vec3 l = normalize(LightPos - pos);\n    vec3 ref = reflect(-l, normal);\n    vec3 a = ka * Ambient * objColor;\n    vec3 d = kd * LightColor * clamp(dot(normal, l),0.0,1.0) * objColor;\n    //vec3 s = ks * LightColor * pow(dot(ref, view), shininess) * objColor;\n    return a + d;// + s;\n}   \n\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.3,0.8,1.0);\n    } else{\n        vec3 n = getNormal(pos);\n        col = lambert(vec3(1,0.8,0.2), pos, n, -rd);\n\t\t//col = vec3(getBumpMap(pos.xz));\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    anim = 0.5*(2.*iTime + .5*sin(1.*iTime+10.0));\n\t\n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3((3.0 + -3.0*mousePos.y) * cos(time + 6.0*mousePos.x), 4.0 , (3.0 + -3.0*mousePos.y) * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0.0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"3tt3zS","date":"1576731439","viewed":45,"name":"Catmull-Rom Spline Demo","description":"Catmull-Rom样条线插值示例","likes":1,"published":"Public","tags":["spline","catmullrom","interpolating"]},"renderpass":[{"code":"#define CR00 -0.5\n#define CR01 1.5\n#define CR02 -1.5\n#define CR03 0.5\n#define CR10 1.0\n#define CR11 -2.5\n#define CR12 2.0\n#define CR13 -0.5\n#define CR20 -0.5\n#define CR21 0.0\n#define CR22 0.5\n#define CR23 0.0\n#define CR30 0.0\n#define CR31 1.0\n#define CR32 0.0\n#define CR33 0.0\n\n#define _spline(x,nKnots,_knots) float _x = x;int _nKnots = nKnots;_x= clamp(_x,0.0,1.0);int _nspan = _nKnots - 3;_x = _x*float(_nspan);int _span = int(floor(_x));if(_span>=_nspan){_span = _nspan - 1;}_x -= float(_span);int _p0 = _span;int _p1 = _span+1;int _p2 = _span+2;int _p3 = _span+3;float _c3 = CR00*_knots[_p0] + CR01*_knots[_p1] + CR02*_knots[_p2] + CR03*_knots[_p3];float _c2 = CR10*_knots[_p0] + CR11*_knots[_p1] + CR12*_knots[_p2] + CR13*_knots[_p3];float _c1 = CR20*_knots[_p0] + CR21*_knots[_p1] + CR22*_knots[_p2] + CR23*_knots[_p3];float _c0 = CR30*_knots[_p0] + CR31*_knots[_p1] + CR32*_knots[_p2] + CR33*_knots[_p3]; v = ((_c3*_x+_c2)*_x+_c1)*_x+_c0;\n\nfloat spline(float x,int nKnots,float[6] knots){  \n    x = clamp(x,0.0,1.0);\n    int nspan = nKnots - 3;\n    \n    x = x*float(nspan);\n    int span = int(floor(x));\n    if(span>=nspan){\n        span = nspan - 1;\n    }\n    x -= float(span);\n    int p0 = span;\n    int p1 = span+1;\n    int p2 = span+2;\n    int p3 = span+3;\n    float c3 = CR00*knots[p0] + CR01*knots[p1] + CR02*knots[p2] + CR03*knots[p3];\n    float c2 = CR10*knots[p0] + CR11*knots[p1] + CR12*knots[p2] + CR13*knots[p3];\n    float c1 = CR20*knots[p0] + CR21*knots[p1] + CR22*knots[p2] + CR23*knots[p3];\n    float c0 = CR30*knots[p0] + CR31*knots[p1] + CR32*knots[p2] + CR33*knots[p3];\n    return ((c3*x+c2)*x+c1)*x+c0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x = uv.x*2.0 - 0.5;\n    \n    int nKnots = 6;\n    float knots[6];\n    knots[0]=1.2;\n    knots[1]=1.0;\n    knots[2]=0.8;\n    knots[3]=0.1;\n    knots[4]=0.0;\n    knots[5]=-0.1;\n   \n    float v = 0.0;\n    if(uv.x > 0.0 && uv.x < 1.0) {\n        _spline(uv.x,nKnots,knots)\n        //v = spline(uv.x,nKnots,knots);\n        v *= 0.9;\n    }\n    \n    vec3 col = vec3(uv.y<v?1.0:0.0);\n    \n    int nspan = nKnots - 3;\n    for(int i = 0; i < nspan - 1; i++){\n         col *= smoothstep(0.0,0.005,abs(uv.x-1.0/float(nspan)*(float(i)+1.0)));\n    }\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"WdKSD3","date":"0","viewed":0,"name":"Distance Estimation - Ellipse","description":"Ellipse - Distance Estimation ","likes":0,"published":"Private","tags":["math"]},"renderpass":[{"code":"// The MIT License\n// Copyright © 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n// An example on how to compute a distance estimation for an ellipse (which provides\n// constant thickness to its boundary). This is achieved by dividing the implicit \n// description by the modulus of its gradient. The same process can be applied to any\n// shape defined by an implicity formula (ellipses, metaballs, fractals, mandelbulbs).\n//\n// top    left : f(x,y)\n// top    right: f(x,y) divided by analytical gradient\n// bottom left : f(x,y) divided by numerical GPU gradient\n// bottom right: f(x,y) divided by numerical gradient\n//\n// More info here:\n//\n// http://www.iquilezles.org/www/articles/distance/distance.htm\n\n#define VERSION 2\n\nconst float a = 1.0;\nconst float b = 3.0;\n\nfloat r, e;\n\n// f(x,y) (top left)\nfloat ellipse1(vec2 p)\n{\n    float f = length( p*vec2(a,b) );\n    return abs(f-r);\n}\n\n// f(x,y) divided by analytical gradient (top right)\nfloat ellipse2(vec2 p)\n{\n    float f = length( p*vec2(a,b) );\n    float g = length( p*vec2(a*a,b*b) );\n    return abs(f-r)*f/g;\n}\n\n// f(x,y) divided by numerical GPU gradient (bottom left)\nfloat ellipse3(vec2 p)\n{\n    float f = ellipse1(p);\n    float g = length( vec2(dFdx(f),dFdy(f))/e );\n    //float g = fwidth(f)/e;\n\treturn f/g;\n}\n\n// f(x,y) divided by numerical gradient (bottom right)\nfloat ellipse4(vec2 p)\n{\n    float f = ellipse1(p);\n    float g = length( vec2(ellipse1(p+vec2(e,0.0))-ellipse1(p-vec2(e,0.0)),\n                           ellipse1(p+vec2(0.0,e))-ellipse1(p-vec2(0.0,e))) )/(2.0*e);\n    return f/g;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    r = 0.9 + 0.1*sin(3.1415927*iTime);\n    e = 2.0/iResolution.y;\n    float zoo = 1.0;\n    vec2 pixelSize = vec2(zoo/iResolution.y*iResolution.x/iResolution.y,zoo/iResolution.y);\n    float eps = sqrt(pixelSize.x*pixelSize.x+pixelSize.y*pixelSize.y);\n    e = eps;\n\tvec2 uv = (2.0*fragCoord-iResolution.xy) / iResolution.y;\n    #if (VERSION == 0)\n\tfloat v = ellipse1(uv);\n    float level = 256.0;\n    v = float(int(v*level))/level;\n    vec3 col = vec3(v);\n    #elif (VERSION == 1)\n    float v = abs(ellipse1(uv));\n    vec3 col = vec3(smoothstep(1.0*e,2.0*e,v));\n    #elif (VERSION == 2)\n    float v = ellipse2(uv);\n     //v = pow(v,0.5);\n    float level = 256.0;\n    v = float(int(v*level))/level;\n    vec3 col = vec3(v);\n    #elif (VERSION == 3)\n     float v = abs(ellipse2(uv));\n    vec3 col = vec3(smoothstep(1.0*e,2.0*e,v));\n    #endif\n    // lines    \n\tcol *= smoothstep( e, 2.0*e, abs(uv.x) );\n\tcol *= smoothstep( e, 2.0*e, abs(uv.y) );\n\t\n\tfragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"wtXXWN","date":"0","viewed":0,"name":"distance estimation to implicits","description":"distance estimation to implicits","likes":0,"published":"Private","tags":["math"]},"renderpass":[{"code":"#define VERSION 3\n\nfloat f(vec2 p)\n{\n    float r = sqrt(p.x*p.x+p.y*p.y);\n    float a = atan(p.y,p.x);\n    return r - 1.0 + sin(3.0*a+2.0*r*r)/2.0;\n    \n}\n\nvec2 grad( in vec2 x )\n{\n    vec2 h = vec2( 0.01, 0.0 );\n    return vec2( f(x+h.xy) - f(x-h.xy),\n                 f(x+h.yx) - f(x-h.yx) )/(2.0*h.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n    p = p*1.5;\n    float zoo = 1.0;\n    vec2 pixelSize = vec2(zoo/iResolution.y*iResolution.x/iResolution.y,zoo/iResolution.y);\n    float eps = sqrt(pixelSize.x*pixelSize.x+pixelSize.y*pixelSize.y);\n    //eps = eps*2.0;\n    \n    float v = f(p);\n    \n    #if (VERSION == 0)\n    eps = eps*2.0;\n    v = abs(v);\n    vec3 color = vec3(smoothstep(1.0*eps,2.0*eps,v));\n    #elif (VERSION == 1)\n    v = abs(v);\n    v = pow(v,0.5);\n    float level = 5.0;\n    v = float(int(v*level))/level;\n    vec3 color = vec3(v);\n    #elif (VERSION == 2)\n    vec2  g = grad(p);\n    float de = v/length(g);\n    de = abs(de);\n    //de = pow(de,0.9);\n    vec3 color = vec3(smoothstep( 1.0*eps, 2.0*eps, de ));\n    #elif (VERSION == 3)\n    vec2  g = grad(p);\n    float de = v/length(g);\n    de = abs(de);\n    de = pow(de,0.5);\n    float level = 256.0;\n    de = float(int(de*level))/level;\n    vec3 color = vec3(de);\n    #endif\n    fragColor = vec4(color,1);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"Wtc3W7","date":"0","viewed":0,"name":"Example of 3D Noise","description":"3d噪声示例","likes":0,"published":"Private","tags":["3d","noise"]},"renderpass":[{"code":"#define AA 2\n\nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos + vec3(0,-1,0), 1.0),1));\n    \n    res = opU(res, vec2(sdPlane(pos),0));\n    \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.8,0.8,1.0);\n    } else{\n         col = vec3(noise(pos*16.0));\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(4.0 * cos(time + 6.0*mousePos.x), 1.0 + 2.0*mousePos.y, 4.0 * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"llKyDc","date":"1576221630","viewed":57,"name":"Examples Of 2D Noise","description":"2d噪声示例","likes":6,"published":"Public","tags":["2d","noise"]},"renderpass":[{"code":"\n//作为基础的随机函数\nvec2 hash22( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n \n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n \n//作为基础的随机函数\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//白噪声\nfloat white_noise(vec2 p){\n    return hash21(ceil(fract(0.77)*12.0)*p);\n}\n\n//基于晶格的值噪声\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve 平滑曲线\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\n\n\n//基于晶格的梯度噪声\n// 算法解析：创建一个由若干虚拟晶格组成的平面，接着给每个晶格的顶点赋予一个随机的向量（通过hash函数生成），\n// 然后通过fract函数将该点平移到【x:0-1, y:0-1】的空间中，再计算到各个晶格顶点的距离向量，\n// 然后将这两个向量进行dot，最后dot的结果利用ease curves（即u）进行双线性插值。\nfloat gradient_noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve 平滑曲线\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n \n    return mix( mix( dot( hash22( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash22( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash22( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                   dot( hash22( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\n \n//simplex噪声 \nfloat simplex_noise(vec2 p)\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\t// 变换到新网格的(0, 0)点\n    vec2 i = floor(p + (p.x + p.y) * K1);\n\t// i - (i.x+i.y)*K2换算到旧网格点\n    // a:变形前输入点p到该网格点的距离\n    vec2 a = p - (i - (i.x + i.y) * K2);\n    vec2 o = (a.x < a.y) ? vec2(0.0, 1.0) : vec2(1.0, 0.0);\n    // 新网格(1.0, 0.0)或(0.0, 1.0)\n    // b = p - (i+o - (i.x + i.y + 1.0)*K2);\n    vec2 b = a - o + K2;\n    // 新网格(1.0, 1.0)\n    // c = p - (i+vec2(1.0, 1.0) - (i.x+1.0 + i.y+1.0)*K2);\n    vec2 c = a - 1.0 + 2.0 * K2;\n\t// 计算每个顶点的权重向量，r^2 = 0.5\n    vec3 h = max(0.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), 0.0);\n    // 每个顶点的梯度向量和距离向量的点乘，然后再乘上权重向量\n    vec3 n = h * h * h * h * vec3(dot(a, hash22(i)), dot(b, hash22(i + o)), dot(c, hash22(i + 1.0)));\n\t\n    // 之所以乘上70，是在计算了n每个分量的和的最大值以后得出的，这样才能保证将n各个分量相加以后的结果在[-1, 1]之间\n    return dot(vec3(70.0, 70.0, 70.0), n);\n}\n\n//基于值噪声的分形噪声\nfloat fractal_noise(in vec2 p)\n{\n\tp *= 5.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tfloat f  = 0.5000*value_noise(p); p = m*p;\n\tf += 0.2500*value_noise(p); p = m*p;\n\tf += 0.1250*value_noise(p); p = m*p;\n\tf += 0.0625*value_noise(p); p = m*p;\n    \n    return f;\n}\n\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy / iResolution.xy;\n \n\tvec2 uv = p * vec2(iResolution.x/iResolution.y,1.0);\n\t\n\tfloat f = 0.0;\n\t\n    // 1: white noise\t\n\tif( p.x<0.2 )\n\t{\n\t\tf = white_noise(uv);\n\t}\n    // 2: value noise\n    else if(p.x>=0.2 && p.x<0.4)\t\n\t{\n        f = value_noise(uv*56.0);\n\t}\n    // 3. gradient noise\n    else if(p.x>=0.4 && p.x<0.6)\n    {\n    \tf = gradient_noise(uv*32.0);\n    }\n    // 4: simplex noise\n    else if(p.x>=0.6 && p.x<0.8)\n    {\n    \tf = simplex_noise(uv*32.0);\n    }\n    // 5: fractal noise\n    else\n    {\n    \tf = fractal_noise(8.0*uv);\n    }\n \n\tf = 0.5 + 0.5*f;\n\t\n    // 分割线：注意如果第三个参数超过了限定范围就不进行插值\n    f *= smoothstep(0.0, 0.005, abs(p.x-0.2));\n    f *= smoothstep(0.0, 0.005, abs(p.x-0.4));\t\n\tf *= smoothstep(0.0, 0.005, abs(p.x-0.6));\n    f *= smoothstep(0.0, 0.005, abs(p.x-0.8));\n    \n\tfragColor = vec4( f, f, f, 1.0 );\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"3dyXDt","date":"0","viewed":0,"name":"Eye-2D","description":"Eye-2D","likes":0,"published":"Private","tags":["2dmodel"]},"renderpass":[{"code":"vec2 hash22( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n \n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n \n    return mix( mix( dot( hash22( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash22( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash22( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                   dot( hash22( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);   \n}\n\nvec3 eye(vec2 p,float b)\n{\n    //b:abs(p.y)与眼睛轮廓曲线的差\n    p -= vec2(0.6,0.05);//圆心\n    float a = atan(p.y,p.x);\n    float d = length(p);//到圆心的距离\n    float e = smoothstep(0.20,0.21,d);//虹膜半径\n    vec3 fue = vec3(1.0,1.0,1.0);//眼白颜色\n    float ven = noise(vec2(24.0*p.x,24.0*p.y));//血丝\n    ven = smoothstep(-0.1,0.0,ven)-smoothstep(0.0,0.1,ven);\n    float x = p.x+0.6;\n    ven += x + x*x*x*x*x*x*7.0;\n    fue.x += 0.04 - 0.01*ven;\n    fue.y += 0.04 - 0.05*ven;\n    fue.z += 0.04 - 0.05*ven;\n    //vec3 den = vec3(0.3,0.7,0.4+d*1.5);//虹膜颜色\n    vec3 den = vec3(160.0/255.0+d*0.2,82.0/255.0+d*0.5,45.0/255.0);//虹膜颜色\n    float noi = 0.8 + 0.2*noise(vec2(d*12.0,24.0*a/3.1415926));//虹膜中径向分布的黑色素\n    den *= noi;\n    float f = smoothstep(0.055,0.065,d);//瞳孔半径\n    den *= f;\n    vec3 col = mix(den,fue,e);\n    float ring = smoothstep(0.18,0.20,d)-smoothstep(0.20,0.22,d);//虹膜的外环\n    ring = 1.0 - 0.35*ring;\n    col *= ring;\n    //反射\n    float r = sqrt(d*d*d);\n    float re = noise(vec2(1.2+32.0*r*cos(a),32.0*r*sin(a)));\n    re = 0.5*smoothstep(0.1f,0.5f,re);\n    col.x += (1.0-col.x)*re;col.y +=(1.0-col.y)*re;col.z += (1.0-col.z)*re;\n    //阴影\n    col*=0.8+0.2*smoothstep(0.0,0.1,-b);\n    return col;\n}\n\nvec3 skin(vec2 p)\n{\n    return vec3(0.0,0.0,0.0);\n}\n\nvec3 draw(vec2 p){\n    p.x = (p.x+1.0)*0.5;\n    p.y = p.y * iResolution.y/(iResolution.x*1.0);   \n    float h = sqrt(p.x*p.x*p.x)*(1.0-p.x);//眼镜的轮廓曲线\n    float e = abs(p.y)-h;\n    float f = smoothstep(0.0,0.01,e);\n    vec3 eye = eye(p,e);\n    vec3 skin = skin(p);\n    vec3 col = mix(eye,skin,f);\n    float ring = smoothstep(-0.01,0.0,e)-smoothstep(0.0,0.01,e);\n    col *= 1.0-ring*0.8;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy) / iResolution.x;\n    \n    vec3 col = draw(uv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"wsyXDV","date":"0","viewed":0,"name":"fbm test1","description":"math fbm noise","likes":0,"published":"Private","tags":["mathfbmnoise"]},"renderpass":[{"code":"// The MIT License\n// Copyright © 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Shows the anisotropic self-similarity of Brownian Motion \n// on the left and the isotropic self-similarity of Fractional\n// Brownian Motion if gain=0.5.\n//\n// On the left, a clasical Brownian Motion is generated, which\n// is a process with Hurst Exponet H=1/2 (uncorrelated deltas,\n// no memory). Such curve has a fractal dimension of 1.5 and\n// needs a vertical scaling factor of sqrt(x) when it's scaled\n// by x horizontally. It's power spectrum decays as f^-2\n//\n// On the right, a Fractional Brownian Motion with H=1\n// which means a gain G of 0.5. It's a long memory curve\n// with possitively correlated increments, has a fractal\n// of 1, and is naturally istropicaly self-similar (non-\n// distorted zoom). Because of that, it's what we use to\n// mimic mountains. It's power spectrum decays as f^-3\n//\n// More info: http://iquilezles.org/www/articles/fbm/fbm.htm\n\n// integer hash copied from Hugo Elias\nfloat hash( int n ) \n{\n\tn = (n << 13) ^ n;\n    n = n * (n * n * 15731 + 789221) + 1376312589;\n    return -1.0+2.0*float( n & ivec3(0x0fffffff))/float(0x0fffffff);\n}\n\n// gradient noise\nfloat gnoise( in float p )\n{\n    int   i = int(floor(p));\n    float f = fract(p);\n\tfloat u = f*f*(3.0-2.0*f);\n    return mix( hash(i+0)*(f-0.0), \n                hash(i+1)*(f-1.0), u);\n}\n\n\nfloat fbmPurest(in float x, in float H )\n{    \n    float t = 0.0;\n    int numOctaves = 16;\n    for( int i=0; i<numOctaves; i++ )\n    {\n        float f = pow( 2.0, float(i) );\n        float a = pow( f, -H );\n        t += a*gnoise(f*x);\n    }\n    return t;\n}\n\nfloat fbmEquivalent( in float x, in float H )\n{    \n    float G = exp2(-H);\n    int numOctaves = 16;\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for( int i=0; i<numOctaves; i++ )\n    {\n        t += a*gnoise(f*x);\n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n}\n\n// fbm\nfloat fbm( in float x, in float G )\n{    \n    x += 26.06;\n    float n = 0.0;\n    float s = 1.0;\n    float a = 0.0;\n    float f = 1.0;    \n    for( int i=0; i<16; i++ )\n    {\n        n += s*gnoise(x*f);\n        a += s;\n        s *= G;\n        f *= 2.0;\n        x += 0.31;\n    }\n    return n;\n}\n\nvec3 anim( in vec2 p, float time )\n{\n    vec3 col = vec3(0.0);\n    \n    //float ani = fract(time/4.0);\n    float ani = smoothstep(0.0,1.0,fract(time/4.0));\n\n    float zoom = pow( 2.0, 6.0*ani );\n    \n\n    if( p.x<0.0 )\n    {\n        vec2 q = vec2(p.x*0.5 + 0.5,p.y);\n        float G = 0.707107;\n\n        float comp = zoom;\n        float comp2 = sqrt(comp);\n\n        if( q.y<0.0 )\n        {\n        float y = -0.5+0.5*comp2*(fbm(0.8*q.x/comp, G ));\n        y += zoom*0.004;\n        col = mix( col, vec3(1.0,1.0,0.5).zyx, 1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y));\n        }\n        else\n        {\n        float y = 0.5+0.5*fbm(0.8*q.x, G );\n        col = mix( col, vec3(1.0,0.5,0.0).zyx, (1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y)));\n        }\n    }\n    else\n    {\n        vec2 q = vec2(p.x*0.5 - 0.5,p.y);\n        float G = 0.5;\n        float comp = zoom;\n        float comp2 = comp;\n        if( p.y<0.0 )\n        {\n        float y = -0.5+0.9*comp2*(fbm(1.0*q.x/comp, G ));\n        y += zoom*0.004;\n        col = mix( col, vec3(1.0,1.0,0.5), 1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y));\n        }\n        else\n        {\n        float y = 0.5+0.9*fbm(1.0*q.x, G );\n        col = mix( col, vec3(1.0,0.5,0.0), 1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y));\n        }\n        \n    }\n       \n    col  *= smoothstep(0.01,0.02,abs(p.x) );\n    col  *= smoothstep(0.01,0.02,abs(p.y) );\n\n    return col;\n}\n\n\n#define AA 5\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec3 col = vec3(0.0);\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        vec2 o = vec2(m,n)/float(AA);\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        col += anim(p,iTime);\n    }\n    col /= float(AA*AA);\n    \n    fragColor = vec4( col, 1.0 );\n    \n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"ttX3Rs","date":"0","viewed":0,"name":"Greate Material Demo","description":"Greate Material Demo","likes":0,"published":"Private","tags":["material"]},"renderpass":[{"code":"/*\n  Written by Alan Wolfe\n  http://demofox.org/\n  http://blog.demofox.org/\n\n  My blog post talking about the techniques in this shadertoy:\n  http://blog.demofox.org/2017/01/09/raytracing-reflection-refraction-fresnel-total-internal-reflection-and-beers-law/\n*/\n\n// A great read on all this stuff:\n// https://graphics.stanford.edu/courses/cs148-10-summer/docs/2006--degreve--reflection_refraction.pdf\n\n// refractive index of some common materials:\n// http://hyperphysics.phy-astr.gsu.edu/hbase/Tables/indrf.html\n#define REFRACTIVE_INDEX_OUTSIDE 1.00029\n#define REFRACTIVE_INDEX_INSIDE  1.125\n\n// lighting parameters\n#define LIGHT_DIRECTIONAL_DIR   normalize(-vec3(1.0,2.0,1.0))\n#define LIGHT_DIRECTIONAL_COLOR vec3(1.0)\n#define LIGHT_AMBIENT           vec3(0.1)\n\n// object type\n#define OBJECT_TYPE 0 // 0 = sphere, 1 = box, 2 = geometric gem shape\n\n// object color parameters\n#define OBJECT_DIFFUSE      vec3(0.0)\n#define OBJECT_SPECPOWER    0.0\n#define OBJECT_REFLECTIVITY 0.01 // How reflective the object is. regardless of fresnel.\n#define OBJECT_ABSORB       vec3(8.0, 8.0, 3.0) // for beers law\n\n// object surface parameters\n#define DO_REFRACTION 1  // 0 to turn off refraction\n#define DO_REFLECTION 1  // 0 to turn off reflection\n#define DO_FRESNEL    1  // 0 to turn off fresnel. fresnel will only show up if reflection is also on.\n\n// rendering params\n#define DO_AA           1  // 0 to turn off 16x jittered SSAA\n#define MAX_RAY_BOUNCES 10 // For box, 2 seems to be max that makes a difference. For sphere, 1 seems to be!\n\n// hash21 from https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\n//============================================================\n// this is ibox() from https://www.shadertoy.com/view/ld23DV\n// Just renamed some things to be more clear and minimized to needed functionality\n// returns t and normal\nvec4 RayIntersectBox ( in vec3 rayOrigin, in vec3 rayDirection, in vec3 boxHalfSizes, out vec2 uv ) \n{\n\t// ray-box intersection\n    vec3 m = 1.0/rayDirection;    // how many steps on each axis to travel 1 unit on that axis\n    vec3 n = m*rayOrigin;         // how many steps on each axis the ray origin is from the object origin\n    vec3 k = abs(m)*boxHalfSizes; // how many steps on each axis it takes to get from the center of the box to the edge\n\t\n    vec3 t1 = -n - k;   // how many steps on each axis to get from the ray origin to the negative surface of the box.\n    vec3 t2 = -n + k;   // how many steps on each axis to get from the ray origin to the positive surface of the box.\n\n\tfloat timeNear = max( max( t1.x, t1.y ), t1.z );\n\tfloat timeFar = min( min( t2.x, t2.y ), t2.z );\n\n\tif( timeNear > timeFar || timeFar < 0.0)\n        return vec4(-1.0);\n\n\t//vec3 normal = -sign(rayDirection)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    \n    if (timeNear < 0.0)\n        timeNear = timeFar;\n    \n    vec3 relPoint = rayOrigin + rayDirection * timeNear;\n    \n    vec3 absRelPoint = abs(relPoint) / boxHalfSizes;\n    \n    vec3 normal;\n    vec3 uaxis;\n    vec3 vaxis;\n    // if Y isn't the biggest value it can't be the normal axis\n    if (absRelPoint.x >= absRelPoint.y)\n    {\n        // if X is the winner\n        if (absRelPoint.x >= absRelPoint.z)\n        {\n            normal = vec3(1.0, 0.0, 0.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(0.0,1.0,0.0);\n\t\t\tvaxis = vec3(0.0,0.0,1.0);            \n        }\n        // else it's Z\n        else\n        {\n            normal = vec3(0.0, 0.0, 1.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,1.0,0.0);            \n        }\n    }\n    // else X isn't the biggest value so it can't be the normal axis\n    else\n    {\n        // if Y is the winner\n        if (absRelPoint.y >= absRelPoint.z)\n        {\n            normal = vec3(0.0, 1.0, 0.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,0.0,1.0);\t           \n        }\n        // else it's Z\n        else\n        {\n            normal = vec3(0.0, 0.0, 1.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,1.0,0.0);            \n        }        \n    }\n    \n\tuv = vec2\n\t(\n\t\tdot(relPoint, uaxis),\n\t\tdot(relPoint, vaxis)\n\t);    \n\n\treturn vec4( timeNear, normal );    \n}\n\n//============================================================\n// returns t and surface normal\n// sphere xyz = position, w = radius\nvec4 RayIntersectSphere (in vec3 rayPos, in vec3 rayDir, in vec4 sphere)\n{\n\t//get the vector from the center of this circle to where the ray begins.\n\tvec3 m = rayPos - sphere.xyz;\n\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn vec4(-1.0);\n\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\n\t//a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn vec4(-1.0);\n\n\t//ray now found to intersect sphere, compute smallest t value of intersection\n\tfloat normalMultiplier = 1.0;\n\tfloat collisionTime = -b - sqrt(discr);\n    if (collisionTime < 0.0)\n    {\n        collisionTime = -b + sqrt(discr);\n        normalMultiplier = -1.0;\n    }\n    \n    // calculate the normal, flipping it if we hit the inside of the sphere\n    vec3 normal = normalize((rayPos+rayDir*collisionTime) - sphere.xyz) * normalMultiplier;\n    \n    // return the time t that the collision happened, as well as the surface normal\n    return vec4 (collisionTime, normal);\n}\n\n//============================================================\n// returns t and surface normal\n// plane xyz = normal, w = d\n// from https://www.cs.princeton.edu/courses/archive/fall00/cs426/lectures/raycast/sld017.htm\nvec4 RayIntersectPlane (in vec3 rayPos, in vec3 rayDir, in vec4 plane, out vec2 uv)\n{   \n    float collisionTime = -(dot(rayPos, plane.xyz)+plane.w) / dot(rayDir, plane.xyz);\n    vec3 uaxis = normalize(cross(plane.xyz, vec3(0.0, 1.0, 0.0)));\n    vec3 vaxis = normalize(cross(plane.xyz, uaxis));\n    vec3 collisionPos = rayPos + rayDir * collisionTime;\n    uv.x = dot(collisionPos, uaxis);\n    uv.y = dot(collisionPos, vaxis);    \n    return vec4(collisionTime, plane.xyz);\n}\n\n//============================================================\nvoid TrimRayInterval (vec3 rayPos, vec3 rayDir, inout vec2 rayMinMax, vec4 plane, inout vec3 nearNormal, inout vec3 farNormal)\n{\n    vec2 uv;\n    vec4 rayInfo = RayIntersectPlane(rayPos, rayDir, plane, uv);   \n    if (dot(rayInfo.yzw, rayDir) < 0.0)\n    {\n        if (rayInfo.x > rayMinMax.x)\n        {\n            rayMinMax.x = rayInfo.x;\n            nearNormal = rayInfo.yzw;\n        }\n    }\n    else\n    {\n        if (rayInfo.x < rayMinMax.y)\n        {\n            rayMinMax.y = rayInfo.x;\n            farNormal = rayInfo.yzw;\n        }\n    }\n}\n\n//============================================================\nvec4 RayIntersectObject (in vec3 rayPos, in vec3 rayDir)\n{\n    #if OBJECT_TYPE == 0\n    \treturn RayIntersectSphere(rayPos, rayDir, vec4(0.0, 0.0, 0.0, 0.5));\n    #elif OBJECT_TYPE == 1\n    \tvec2 uv;\n    \tvec4 ret = RayIntersectBox(rayPos, rayDir, vec3(0.5), uv);\n    \tif (dot(rayDir, ret.yzw) > 0.0)\n            ret.yzw *= -1.0;\n    \treturn ret;\n    #else\n    \tvec2 rayMinMax = vec2(-1.0, 1000.0);\n    \tvec3 nearNormal;\n    \tvec3 farNormal;\n    \n    \tfloat size = -0.5;\n    \tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 1.0, 0.2, -0.4)), size), nearNormal, farNormal);\n\t\tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3(-1.0, 0.2, -0.4)), size), nearNormal, farNormal);   \n    \tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0, 1.0,  1.0)), size*0.5), nearNormal, farNormal);\n\t\tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0,-1.0,  0.0)), size), nearNormal, farNormal);   \n    \tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0,-0.3,  1.0)), size), nearNormal, farNormal);\n\t\tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0, 0.3, -1.0)), size), nearNormal, farNormal);     \n\n    \tif (rayMinMax.x > rayMinMax.y)\n            return vec4(-1.0);\n    \n    \tif (rayMinMax.x > 0.0)\n    \t\treturn vec4(rayMinMax.x, nearNormal);\n    \telse\n            return vec4(rayMinMax.y, -farNormal);\n    #endif\n}\n\n//============================================================\nvec3 Checkerboard (vec2 uv)\n{\n    return vec3(mod(floor(uv.x * 4.0) + floor(uv.y * 4.0), 2.0) < 1.0 ? 1.0 : 0.4);\n}\n\n//============================================================\nvec3 LightPixel (vec3 rayPos, vec3 rayDir, vec3 diffuse, vec3 normal, float specPower, bool doShadow)\n{   \n    // ambient\n    vec3 pixelColor = diffuse * LIGHT_AMBIENT;\n    \n    // see if we are in shadow by casting in the light direction and seeing if we hit the object.\n    // if we do hit the object, return just the ambient lighting shaded color we have already calculated.\n    if (doShadow && normal.y >= 0.9 && RayIntersectObject(rayPos, -LIGHT_DIRECTIONAL_DIR).x >= 0.0)\n        return pixelColor;\n    \n    // diffuse\n    float dp = clamp(dot(normal, -LIGHT_DIRECTIONAL_DIR), 0.0, 1.0);\n    pixelColor += diffuse * dp * LIGHT_DIRECTIONAL_COLOR;\n    \n    // specular highlight\n    if (specPower > 0.0)\n    {\n    \tvec3 reflection = reflect(-LIGHT_DIRECTIONAL_DIR, normal);\n    \tdp = clamp(dot(rayDir, reflection), 0.0, 1.0);\n\t\tpixelColor += LIGHT_DIRECTIONAL_COLOR * pow(dp, specPower);    \n    }\n    \n    return pixelColor;\n}\n\n//============================================================\nfloat FresnelReflectAmount (float n1, float n2, vec3 normal, vec3 incident)\n{\n    #if DO_FRESNEL\n        // Schlick aproximation\n        float r0 = (n1-n2) / (n1+n2);\n        r0 *= r0;\n        float cosX = -dot(normal, incident);\n        if (n1 > n2)\n        {\n            float n = n1/n2;\n            float sinT2 = n*n*(1.0-cosX*cosX);\n            // Total internal reflection\n            if (sinT2 > 1.0)\n                return 1.0;\n            cosX = sqrt(1.0-sinT2);\n        }\n        float x = 1.0-cosX;\n        float ret = r0+(1.0-r0)*x*x*x*x*x;\n\n        // adjust reflect multiplier for object reflectivity\n        ret = (OBJECT_REFLECTIVITY + (1.0-OBJECT_REFLECTIVITY) * ret);\n        return ret;\n    #else\n    \treturn OBJECT_REFLECTIVITY;\n    #endif\n}\n\n//============================================================\nvec3 GetSceneRayColor (in vec3 rayPos, in vec3 rayDir)\n{\n    // Returns the lit RGB for this ray intersecting with the scene, ignoring the main object.\n    // Used for reflection off the surface of the object, and refraction out the back of the object.\n    \n    // if we hit the box, return the lit box color\n    vec2 uv;\n    vec4 rayInfo = RayIntersectBox(rayPos + vec3(0.0, 1.51, 0.0), rayDir, vec3(1.0, 1.0, 1.0), uv);\n    if (rayInfo.x >= 0.0)\n        return LightPixel(rayPos + rayDir*rayInfo.x, rayDir, Checkerboard(uv), rayInfo.yzw, 100.0, true);\n    // else return skybox color\n    else\n        return texture(iChannel0, rayDir).rgb;\n}\n\n//============================================================\nvec3 GetObjectInternalRayColor (in vec3 rayPos, in vec3 rayDir)\n{\n    // bounce around inside the object as many times as needed (or until max bounces) due total internal reflection\n    float multiplier = 1.0;\n    vec3 ret = vec3(0.0);\n    float absorbDistance = 0.0;\n\tfor (int i = 0; i < MAX_RAY_BOUNCES; ++i)\n    {\n        // try and intersect the object\n    \tvec4 rayInfo = RayIntersectObject(rayPos, rayDir);\n        \n        // should \"never\" happen but handle it anyways\n    \tif (rayInfo.x < 0.0)  \n            return ret;\n        \n        // move the ray position to the intersection point.\n        rayPos = rayPos + rayDir * rayInfo.x;\n        \n        // calculate beer's law absorption.\n        absorbDistance += rayInfo.x;    \n        vec3 absorb = exp(-OBJECT_ABSORB * absorbDistance);\n        \n        // calculate how much to reflect or transmit (refract or diffuse)\n        float reflectMultiplier = FresnelReflectAmount(REFRACTIVE_INDEX_INSIDE, REFRACTIVE_INDEX_OUTSIDE, rayDir, rayInfo.yzw);\n        float refractMultiplier = 1.0 - reflectMultiplier;\n        \n        // add in refraction outside of the object\n        vec3 refractDir = refract(rayDir, rayInfo.yzw, REFRACTIVE_INDEX_INSIDE / REFRACTIVE_INDEX_OUTSIDE);\n        ret += GetSceneRayColor(rayPos + refractDir*0.001, refractDir) * refractMultiplier * multiplier * absorb;\n        \n        // add specular highlight based on refracted ray direction\n        ret += LightPixel(rayPos, rayDir, OBJECT_DIFFUSE, refractDir, OBJECT_SPECPOWER, false) * refractMultiplier * multiplier * absorb; \n        \n        // follow the ray down the internal reflection path.\n        rayDir = reflect(rayDir, rayInfo.yzw);\n        \n        // move the ray slightly down the reflect path\n        rayPos += rayDir * 0.001;\n        \n        // For reflection, we are only going to be reflecting what is refracted on further bounces.\n        // So, we just need to make sure the next bounce is added in at the reflectMultiplier amount, recursively.\n\t\tmultiplier *= reflectMultiplier;        \n    }\n    \n    // return the color we calculated\n    return ret;\n}\n\n//============================================================\nvec3 RayTracePixelColor (in vec3 rayPos, in vec3 rayDir)\n{   \n    vec4 bestRayHitInfo = vec4(1000.0, 0.0, 0.0, 0.0);\n    vec3 rayHitDiffuse = vec3(1.0);\n    vec3 additiveColor = vec3(0.0);\n    \n    vec3 ret = vec3(0.0);\n           \n    // see if we've hit the platform and remember if we have\n    vec2 uv;    \n    vec4 rayInfo = RayIntersectBox(rayPos + vec3(0.0, 1.51, 0.0), rayDir, vec3(1.0, 1.0, 1.0), uv);\n    if (rayInfo.x >= 0.0 && rayInfo.x < bestRayHitInfo.x)\n    {\n        bestRayHitInfo = rayInfo;\n        rayHitDiffuse = Checkerboard(uv);\n    }\n    \n    // if we've hit the main object, and it's closer than the platform\n    rayInfo = RayIntersectObject(rayPos, rayDir);\n    if (rayInfo.x >= 0.0 && rayInfo.x < bestRayHitInfo.x)\n    {       \n        // light the surface of the ball a bit\n        additiveColor += LightPixel(rayPos, rayDir, OBJECT_DIFFUSE, rayInfo.yzw, OBJECT_SPECPOWER, false);\n        \n        // move the ray to the intersection point\n        rayPos += rayDir * rayInfo.x;    \n        \n        // calculate how much to reflect or transmit (refract or diffuse)\n        float reflectMultiplier = FresnelReflectAmount(REFRACTIVE_INDEX_OUTSIDE, REFRACTIVE_INDEX_INSIDE, rayDir, rayInfo.yzw);\n        float refractMultiplier = 1.0 - reflectMultiplier;\n        \n        // get reflection color\n        #if DO_REFLECTION\n        \tvec3 reflectDir = reflect(rayDir, rayInfo.yzw);\n        \tret += GetSceneRayColor(rayPos + reflectDir*0.001, reflectDir) * reflectMultiplier;\n        #endif\n        \n        // get refraction color\n        #if DO_REFRACTION\n        \tvec3 refractDir = refract(rayDir, rayInfo.yzw, REFRACTIVE_INDEX_OUTSIDE / REFRACTIVE_INDEX_INSIDE);\n        \tret += GetObjectInternalRayColor(rayPos + refractDir*0.001, refractDir) * refractMultiplier;\n        #endif\n        \n        return ret + additiveColor;\n    }\n    // else we missed the object, so return either the skybox color, or the platform color, as appropriate\n    else\n    {\n        if (bestRayHitInfo.x == 1000.0)    \n            return texture(iChannel0, rayDir).rgb;\n        else\n        {\n            // move the ray to the intersection point (so we can shadow) and light the pixel\n        \trayPos += rayDir * bestRayHitInfo.x;    \n            return LightPixel(rayPos, rayDir, rayHitDiffuse, bestRayHitInfo.yzw, 100.0, true);    \n        }\n    }\n}\n\n//============================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n    //----- Camera Setup\n    vec2 mouse = iMouse.xy / iResolution.xy;\n\n    vec3 cameraAt \t= vec3(0.0);\n\n    float angleX = iMouse.z > 0.0 ? 6.28 * mouse.x : 3.14 + iTime * 0.25;\n    float angleY = iMouse.z > 0.0 ? (mouse.y * 6.28) - 0.4 : 0.5;\n    vec3 cameraPos\t= (vec3(sin(angleX)*cos(angleY), sin(angleY), cos(angleX)*cos(angleY))) * 3.0;\n\n    vec3 cameraFwd  = normalize(cameraAt - cameraPos);\n    vec3 cameraLeft  = normalize(cross(normalize(cameraAt - cameraPos), vec3(0.0,sign(cos(angleY)),0.0)));\n    vec3 cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n\n    float cameraViewWidth\t= 6.0;\n    float cameraViewHeight\t= cameraViewWidth * iResolution.y / iResolution.x;\n    float cameraDistance\t= 6.0;  // intuitively backwards!\n\n    //----- Ray Setup\n    vec2 rawPercent = (fragCoord.xy / iResolution.xy); \n    vec2 percent = rawPercent - vec2(0.5,0.5);\n\n    vec3 rayTarget = (cameraFwd * vec3(cameraDistance,cameraDistance,cameraDistance))\n        - (cameraLeft * percent.x * cameraViewWidth)\n        + (cameraUp * percent.y * cameraViewHeight);\n    vec3 rayDir = normalize(rayTarget);    \n\n    //----- Ray Trace\n    vec3 finalColor = vec3(0.0);\n    #if DO_AA\n        for (int i = 1; i <= 16; ++i)\n        {\n            // calculate stratified subpixel jitter in a 4x4 grid\n            float x = mod(float(i)-1.0, 4.0);\n            float y = mod(floor(float(i) / 4.0), 4.0);\n            vec2 jitter = hash21(float(i)) / 4.0;\n            jitter.x += x / 4.0;\n            jitter.y += y / 4.0;\n            \n            // set up the jittered ray\n            rawPercent = ((fragCoord.xy + jitter) / iResolution.xy); \n            percent = rawPercent - vec2(0.5,0.5);\n\n            rayTarget = (cameraFwd * vec3(cameraDistance,cameraDistance,cameraDistance))\n                - (cameraLeft * percent.x * cameraViewWidth)\n                + (cameraUp * percent.y * cameraViewHeight);\n            rayDir = normalize(rayTarget);                \n           \n\t\t\t// raytrace\n            vec3 color = RayTracePixelColor(cameraPos, rayDir);\n            \n            // incrementally average our pixel color in\n            finalColor = mix(finalColor, color, 1.0 / float(i));            \n        }\n    #else\n   \t\tfinalColor = RayTracePixelColor(cameraPos, rayDir);\n    #endif\n    \n    //----- Final color, gamma corrected\n    fragColor = vec4(pow(finalColor, vec3(1.0/2.2)),1.0);        \n}\n\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"3lsXWH","date":"1562757823","viewed":94,"name":"Mandelbrot Set Render1","description":"render of Mandelbrot set","likes":1,"published":"Public","tags":["fractal"]},"renderpass":[{"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n    // animation\t\n\tfloat tz = 0.5 - 0.5*cos(0.225*iTime);\n    float zoo = pow( 0.5, 13.0*tz );\n\tvec2 c = vec2(-0.05,.6805) + p*zoo;\n\n    // iterate\n    vec2 z  = vec2(0.0);\n    float m2 = 0.0;\n    int isIn = 1;\n    for( int i=0; i<200; i++ )\n    {\n        if( m2 > 2.0 ) { isIn = 0; break; }\n\t\t\t\n        // Z -> Z² + c\t\t\t\n        z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n\t\t\t\n        m2 = dot(z,z);\n    }\n\n    vec3 col = vec3(isIn==1?0:1 );\n    \n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"wtlSW8","date":"1562830347","viewed":88,"name":"Mandelbrot Set Render2","description":"mandelbrot set Render2\nreferences:\nhttps://www.shadertoy.com/view/lsX3W4\n","likes":1,"published":"Public","tags":["fractal"]},"renderpass":[{"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n    // animation\t\n\tfloat tz = 0.5 - 0.5*cos(0.225*iTime);\n    float zoo = pow( 0.5, 13.0*tz );//[1/2^12,1]\n\tvec2 c = vec2(-0.05,.6805) + p*zoo;\n\n    // iterate\n    bool isIn = true;\n    vec2 z  = vec2(0.0);\n    float m2 = 0.0;\n    vec2 dz = vec2(0.0);\n    for( int i=0; i<200; i++ )\n    {\n        if( m2>1024.0 ) { isIn=false; break; }\n\n\t\t// Z' -> 2·Z·Z' + 1\n        dz = 2.0*vec2(z.x*dz.x-z.y*dz.y, z.x*dz.y + z.y*dz.x) + vec2(1.0,0.0);\n\t\t\t\n        // Z -> Z² + c\t\t\t\n        z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n\t\t\t\n        m2 = dot(z,z);\n    }\n\n    // distance\t\n\t// d(c) = |Z|·log|Z|/|Z'|\n    float d = 0.5*sqrt(dot(z,z)/dot(dz,dz))*log(dot(z,z));\n    if (isIn)\n        d = 0.0;\n\t\n    // estimate density in the pixel area\n    vec2 pixelScale = vec2(zoo/iResolution.y*iResolution.x/iResolution.y,zoo/iResolution.y);\n    float pixelArea = pixelScale.x * pixelScale.y;\n    float k = 2.0;\n    float density = clamp((pixelArea - 3.1415926*d*d*k)/pixelArea, 0.0, 1.0);\n    density = pow(density,3.0);\n                  \n    vec3 col = vec3( mix(1.0,0.0,density) );\n    \n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"3lfXW4","date":"0","viewed":0,"name":"Mandelbrot Set Render3","description":"Mandelbrot Set Render","likes":0,"published":"Private","tags":["fractal"]},"renderpass":[{"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n    // animation\t\n\tfloat tz = 0.5 - 0.5*cos(0.225*iTime);\n    float zoo = pow( 0.5, 13.0*tz );//[1/2^12,1]\n\tvec2 c = vec2(-0.05,.6805) + p*zoo;\n\n    // iterate\n    bool isIn = true;\n    vec2 z  = vec2(0.0);\n    float m2 = 0.0;\n    vec2 dz = vec2(0.0);\n    int iterMax = 0;\n    for( int i=0; i<200; i++ )\n    {\n        if( m2>1024.0 ) { isIn=false; break; }\n\n\t\t// Z' -> 2·Z·Z' + 1\n        dz = 2.0*vec2(z.x*dz.x-z.y*dz.y, z.x*dz.y + z.y*dz.x) + vec2(1.0,0.0);\n\t\t\t\n        // Z -> Z² + c\t\t\t\n        z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n\t\t\t\n        m2 = dot(z,z);\n        iterMax++;\n    }\n\n    // distance\t\n\t// d(c) = |Z|·log|Z|/|Z'|\n    float d = 0.5*sqrt(dot(z,z)/dot(dz,dz))*log(dot(z,z));\n    if (isIn)\n        d = 0.0;\n\t\n    // estimate density in the pixel area\n    vec2 pixelScale = vec2(zoo/iResolution.y*iResolution.x/iResolution.y,zoo/iResolution.y);\n    float pixelArea = pixelScale.x * pixelScale.y;\n    float k = 2.0;\n    float density = clamp((pixelArea - 3.1415926*d*d*k)/pixelArea, 0.0, 1.0);\n    \n    density = pow(density,3.0);\n    \n    vec2 vCorner = vec2(pixelScale.x*iResolution.x/2.0, pixelScale.y*iResolution.y/2.0);\n    float dmax = sqrt(vCorner.x*vCorner.x+vCorner.y*vCorner.y);\n    float dN = d/dmax;\n    \n    vec4 col = vec4(128.0,0,128.0,1.0);\n    if(density > 0.01){\n        col = vec4(mix(1.0,0.0,density)); \n    }else{\n        col = vec4(mix(1.0,0.0,d/dmax));\n        //col = vec4(1.0);\n    }\n    fragColor = col;\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"Wtc3DM","date":"1576576570","viewed":44,"name":"Marble Material","description":"程序性的大理石材质，看起来更像拼合板","likes":2,"published":"Public","tags":["marble","fractalnoise"]},"renderpass":[{"code":"#define CR00 -0.5\n#define CR01 1.5\n#define CR02 -1.5\n#define CR03 0.5\n#define CR10 1.0\n#define CR11 -2.5\n#define CR12 2.0\n#define CR13 -0.5\n#define CR20 -0.5\n#define CR21 0.0\n#define CR22 0.5\n#define CR23 0.0\n#define CR30 0.0\n#define CR31 1.0\n#define CR32 0.0\n#define CR33 0.0\n\n#define PALE_BLUE vec3(0.25,0.25,0.35)\n#define MEDIUM_BLUE vec3(0.10,0.10,0.30)\n#define DARK_BLUE vec3(0.05,0.05,0.26)\n#define DARKER_BLUE vec3(0.03,0.03,0.20)\n\n#define Ambient vec3(0.1,0.1,0.1)\n\n#define NearClipPlaneDist 2.0\n\n#define AA 2\n\nfloat hash31(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise3d( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    return mix(mix(mix( hash31(i+vec3(0,0,0)), \n                        hash31(i+vec3(1,0,0)),f.x),\n                   mix( hash31(i+vec3(0,1,0)), \n                        hash31(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash31(i+vec3(0,0,1)), \n                        hash31(i+vec3(1,0,1)),f.x),\n                   mix( hash31(i+vec3(0,1,1)), \n                        hash31(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat marble(vec3 p){\n    float m = 0.0;\n    float f = 1.0;\n    for(float i = 0.0; i < 4.0; i += 1.0){\n        m += noise3d(p*f)/f;\n        f*=2.17;\n    }\n    return m;\n}\n\n//根据m在colors[1]到colors[n-1]之间进行样条线插值\nvec3 marbleColor(float m){\n    m = clamp(0.0,1.0,m);\n    float nspan = 10.0;\n    vec3 colors[13];\n    colors[0]=PALE_BLUE;\n    colors[1]=PALE_BLUE;\n    colors[2]=MEDIUM_BLUE;\n    colors[3]=MEDIUM_BLUE;\n    colors[4]=MEDIUM_BLUE;\n    colors[5]=PALE_BLUE;\n    colors[6]=PALE_BLUE;\n    colors[7]=DARK_BLUE;\n    colors[8]=DARK_BLUE;\n    colors[9]=DARKER_BLUE;\n    colors[10]=DARKER_BLUE;\n    colors[11]=PALE_BLUE;\n    colors[12]=DARKER_BLUE;\n    colors[12]=DARKER_BLUE;\n    \n    m = clamp(0.0,1.0,m)*nspan;\n    float span = floor(m);\n    if(span>=nspan){\n        span = nspan - 1.0;\n    }\n    m -= span;\n    int p0 = int(span);\n    int p1 = int(span+1.0);\n    int p2 = int(span+2.0);\n    int p3 = int(span+3.0);\n    vec3 c3 = CR00*colors[p0] + CR01*colors[p1] + CR02*colors[p2] + CR03*colors[p3];\n    vec3 c2 = CR10*colors[p0] + CR11*colors[p1] + CR12*colors[p2] + CR13*colors[p3];\n    vec3 c1 = CR20*colors[p0] + CR21*colors[p1] + CR22*colors[p2] + CR23*colors[p3];\n    vec3 c0 = CR30*colors[p0] + CR31*colors[p1] + CR32*colors[p2] + CR33*colors[p3];\n    return ((c3*m+c2)*m+c1)*m+c0;\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n    res = opU(res, vec2(sdBox(pos, vec3(1.5,0.1,1.0)),1));\n    //res = opU(res, vec2(sdSphere(pos + vec3(0,-1,0), 1.0),1));\n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 normal = vec3(0,0,0);\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = Ambient;\n    } else {\n        float m = marble(pos*2.0);\n        m = 0.5*m;\n        col = marbleColor(m);\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(3.0 * cos(time + 6.0*mousePos.x), 2.0 + 2.0*mousePos.y, 3.0 * sin(time + + 6.0*mousePos.x));\n    \n    vec3 lookAtPos = vec3(0,0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 pixelPosInCameraCoor = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(pixelPosInCameraCoor.xy, NearClipPlaneDist));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    sum /= float(AA*AA);\n    // Output to screen\n    fragColor = vec4(sum, 1);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"3lXGRs","date":"0","viewed":0,"name":"Mesh Render","description":"Mesh Render","likes":0,"published":"Private","tags":["mesh"]},"renderpass":[{"code":"float NearClipPlaneDist = 2.0;\nvec3 LightPos = vec3(5,5,5);\nvec3 LightColor = vec3(1,1,1);\nvec3 Ambient = vec3(0.1,0.1,0.1);\n\n// http://iquilezles.org/www/articles/intersectors/intersectors.htm\nbool boxIntersect( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad ) \n{\n\tvec3 roo = ro - cen;\n    if( abs(roo.x)<rad.x && \n        abs(roo.y)<rad.y && \n        abs(roo.z)<rad.z )\n        return true;\n\n    vec3 m = 1.0/rd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\treturn ( tN < tF && tF > 0.0);\n}\n\n// http://iquilezles.org/www/articles/intersectors/intersectors.htm\nvec3 triIntersect( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 v1v0 = v1 - v0;\n    vec3 v2v0 = v2 - v0;\n    vec3 rov0 = ro - v0;\n\n    vec3  n = cross( v1v0, v2v0 );\n    vec3  q = cross( rov0, rd );\n    float d = 1.0/dot( rd, n );\n    float u = d*dot( -q, v2v0 );\n    float v = d*dot(  q, v1v0 );\n    float t = d*dot( -n, rov0 );\n\n    if( u<0.0 || v<0.0 || (u+v)>1.0 ) t = -1.0;\n    \n    return vec3( t, u, v );\n}\n\nbool intersectMesh( in vec3 ro, in vec3 rd, float tmax, out float oDis, out vec3 oNor, out vec2 oUV, out int oTri )\n{\n    ro.z += 0.5;\n    if( !boxIntersect( ro, rd, vec3(0.0), vec3(0.18,0.3,0.52) ) )\n        return false;\n    bool res = false;\n    float tmin = tmax;\n    for( int i=0; i<numFaces; i++ )\n    {\n\t\t// get the triangle\n        vec3 v0 = getVertex(i,0);\n        vec3 v1 = getVertex(i,1);\n        vec3 v2 = getVertex(i,2);\n\n        vec3 h = triIntersect( ro, rd, v0, v1, v2 );\n        if( h.x>0.0 && h.x<tmin)\n        {\n            tmin = h.x;\n            oNor = normalize(cross(v1-v0,v2-v0));;\n            oDis = tmin;\n            oUV = h.yz;\n            oTri = i;\n            res = true;\n        }\n    }\n    \n    return res;\n}\n\nvec3 lambert(in vec3 pos, in vec3 normal, in vec3 view)\n{\n    float ka = 0.5;\n    float kd = 1.0;\n    float ks = 0.5;\n    float shininess = 2.0;\n    vec3 objCol = vec3(1,0.8,0.2);\n    vec3 l = normalize(LightPos - pos);\n    vec3 ref = reflect(-l, normal);\n    vec3 a = ka * Ambient * objCol;\n    vec3 d = kd * LightColor * dot(normal, l) * objCol;\n    vec3 s = ks * LightColor * pow(dot(ref, view), shininess) * objCol;\n    return a + d + s;\n}   \n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    float tmin = 1e10; \n    vec3 nor = vec3(0.0);\n    float t;\n    vec3 tnor;\n    vec2 uv;\n    int ttri;\n    if( intersectMesh( ro, rd, tmin, t, tnor, uv, ttri ) )\n    {\n        vec3 p = ro + rd * t;\n        return lambert(ro, tnor, rd);             \n               \n    }\n    return Ambient;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mousePos = iMouse.xy / iResolution.xy;\n    float time = iTime * 0.5;\n    vec3 cameraPos = vec3(2.0 * cos(time + 6.0*mousePos.x), 1.0 + mousePos.y, 2.0 * sin(time + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    vec2 pixelPosInCameraCoor = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    \n    vec3 rayDir = viewMatrix * normalize(vec3(pixelPosInCameraCoor.xy, NearClipPlaneDist));\n    vec3 col = render(cameraPos, rayDir);\n    col = pow( col, vec3(0.4545) );\n    // Output to screen\n    fragColor = vec4(col.xyz, 1);\n}","name":"Image","description":"","type":"image"},{"code":"// Created by inigo quilez - iq/2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Fox model by pixelmannen: https://opengameart.org/content/fox-and-shiba\n//\n// NOT optimized for size, this model fits in a few hundred bytes really\n\nconst int numVertices = 290;\nconst int numFaces = 576;\n\nconst uint vertices[290] = uint[](\n 474194016U,  456372306U,  352611409U, 1003915346U,  997632126U, 1028056178U, 1012359285U, 1022864486U,\n1063764050U, 1051144299U, 1067953244U,  969343123U,  952500360U,  927354003U,  785584243U,  781389931U,\n 774033519U,  921167985U,  925333648U,  881367204U, 1044830290U, 1073188946U,  968207442U,  373581952U,\n 378821737U,  518232191U,  563316854U,  564356178U,  554918994U,  517177432U,  517177426U,  397597808U,\n 764610662U,  740491357U,  743613546U,   96613484U,   96606290U,    1245285U,   89298044U,  175384658U,\n  79914097U,    5465187U,  563317884U,  562283660U,  709059699U,  823379026U,  800305248U,  819190910U,\n 877969536U,  875891851U,  517180522U,  738414674U,  351569006U,    7574610U,     191570U,  474193989U,\n 880049234U, 1028056114U,  997632038U, 1012359215U, 1022864447U, 1051144250U, 1067953224U,  969342993U,\n 952500252U,  927353873U,  785584177U,  775078965U,  781389881U,  921167923U,  881367040U,  925333524U,\n 373581860U,  378821691U,  563316783U,  518232102U,  517177420U,  397597749U,  764610622U,  742566971U,\n 743637063U,   96613433U,    1245247U,   89297960U,    5465153U,   79914035U,  563317800U,  709059633U,\n 562283545U,  819189798U,  800305220U,  877969444U,  875891738U,  517180474U,  351568949U,  518251537U,\n 518250643U,  327376978U,  320046201U,  562288788U,  706982036U,  529968210U,  554084434U,  555106425U,\n 467011731U,  373674127U,  373624984U,  351600768U,  462755997U,  723707023U,  786839700U,  786881618U,\n 851924050U,  781551771U,  855036037U,  888589462U,  859273329U,  851940434U,  915932242U,  989311074U,\n 996652114U,  874857619U,  507730063U,  207761533U,  687205523U,  687247442U,  741788754U,  456565842U,\n 373704786U,  351650897U,  448997534U,  515069056U,  396551310U,  381872256U,  370278535U,  373422219U,\n 366061706U,  369207409U,  398579827U,  388097136U,  368183419U,  363992192U,  355579008U,  382856303U,\n 376566897U,  422716549U,  741538966U,  737264781U,  722664559U,  730978425U,  813981713U,  780341269U,\n 796070948U,  303384658U,  347428982U,  292862076U,  202548362U,  305407108U,  351600675U,  347428909U,\n 292861992U,  305407008U,  188987525U,  207754322U,  184813687U,  862336152U,  796071040U,  560236698U,\n 736498836U,  556137619U,  767726734U,  320046123U,  706981904U,  562288657U,  467011601U,  555106347U,\n 736458761U,  734256144U,  781551625U,  373674005U,  373624844U,  462755847U,  725807125U,  786839568U,\n 855035935U,  888589326U,  859273268U,  813981843U,  989311042U,  874857489U,  507729941U,  207761448U,\n 687205393U,  448997382U,  515068964U,  397599767U,  381872165U,  370278429U,  366061594U,  374470681U,\n 398579762U,  368183337U,  355578916U,  363992100U,  382856245U,  369207347U,  376566835U,  422716447U,\n 388097076U,  710014999U,  743635982U,  705827884U,  726861877U,  188987423U,  202548250U,  184813613U,\n 862336012U,  560236555U,  736498705U,  556137489U,  763526166U,  558185480U,  691365896U,  558185629U,\n 691366044U,  780341392U,  786609188U,  786613376U,  734256276U,  736458908U,  383898646U,  383898766U,\n 403811460U,  399539312U,  392218767U,  396364927U,  405822607U,  402699380U,  441454711U,  413141103U,\n 413141135U,  441454726U,  408990847U,  735105158U,  742427768U,  743560303U,  770818184U,  780255360U,\n 773890175U,  770819193U,  763480176U,  752921712U,  747753581U,  764527756U,  791682165U,  748685428U,\n 749735053U,  790633610U,  747671692U,  759212170U,  804262017U,  403811360U,  399539253U,  392218645U,\n 396364837U,  405822485U,  402699313U,  441454638U,  413141045U,  413141013U,  441454622U,  408990757U,\n 677453854U,  716306485U,  675338285U,  738309148U,  705737765U,  746693668U,  738311211U,  688972852U,\n 733071412U,  720498744U,  693162011U,  733070360U,  706748464U,  665867313U,  705699867U,  666916888U,\n 680580120U,  716177443U );\n\nconst uint faces[576] = uint[](\n  524800U,  1312771U,  2100742U,  2624521U,  1578500U,  2890252U,  4201998U,  4989969U,\n 2361876U,  5509652U,   792598U,   536599U,  7091225U,  7353881U,  7879168U,   277504U,\n 8138752U,  8929824U,  9717795U,  9717286U, 10768423U,  9718824U, 11556394U,   524312U,\n12344365U,  1054723U,  1312276U,  2100234U,  1575433U,  2626069U,  1574917U, 12869168U,\n 2889732U, 13121561U, 12084781U,   536116U,  6566954U,  7616562U,  8412175U, 10767925U,\n14174245U,  9719849U, 10775094U, 10775589U,   263223U, 14704687U, 11825199U, 15233539U,\n15732795U, 15498301U, 16545338U, 17071680U, 17860162U, 18648133U, 14973460U, 16001556U,\n16778774U, 19137608U, 19412508U, 19698716U, 19938305U, 14456833U, 19175991U, 21012046U,\n 9479249U, 21275731U, 22325287U, 21800021U, 23113302U, 14419017U, 23638573U, 16806915U,\n  815636U, 15470654U, 14972477U, 16022549U, 15234617U, 23378011U, 16809530U,  7387723U,\n13415469U, 18875486U, 19437142U, 19951197U, 23632964U, 10266677U,  9464914U, 22324308U,\n13936694U, 14198866U, 14703193U, 23883865U, 12327951U, 12082703U,  4211744U,  3940384U,\n23376964U, 17347140U, 12075041U, 13392929U, 23619152U, 20493392U, 17598542U, 20743758U,\n19709528U, 22582872U,  7115827U, 22832714U, 22589002U,  6575147U, 25178667U,  6829619U,\n11555866U, 13391898U,  7617564U,  7903260U, 19970588U,  7627776U, 16823900U, 17072220U,\n 5795931U, 16788571U,  3152433U, 12589105U,  5773360U, 14691376U, 25429044U, 25454690U,\n25974316U, 26265132U, 27053157U, 27315813U, 28103785U, 27842664U, 13643370U, 28624940U,\n29417070U, 29940849U, 30467187U,  4777485U, 30993012U, 30728306U,  1582091U,  5040243U,\n31203858U,  2158599U,  1895942U,  3469873U,  5039634U,  4989556U, 25716843U, 32030828U,\n32293474U, 31255569U, 33094268U, 27578495U, 33870464U, 34134122U, 34353760U, 34657303U,\n34876952U, 35720838U, 36508809U, 36201603U, 37296780U, 35987599U, 38078074U, 38073474U,\n35987083U, 38610029U, 39135266U, 39660633U, 39923289U, 38819891U, 39115412U, 40711321U,\n41236578U, 42024606U, 42287262U, 10041506U,  9520763U,  9238172U, 10568868U, 10569767U,\n13120131U, 33345637U, 28103322U, 40424065U, 27840617U, 29162606U, 13685867U, 29416562U,\n29942437U, 28596372U,  4725259U, 30729332U, 31517815U, 31204358U, 31518215U, 38324333U,\n 3694246U, 26300003U, 40436377U, 32036994U, 32294044U, 30992401U, 33093800U, 27590272U,\n34133124U, 27349607U, 34390138U, 34614917U, 34877471U, 36463754U, 38823457U, 44639379U,\n42545828U, 42779259U, 43069991U, 40710818U, 10044456U,  9500195U,  9254950U,   574046U,\n24691371U, 23157420U, 22851756U, 26828462U, 26528942U, 39412400U, 46738608U, 47266995U,\n47540398U, 18922676U, 45182039U, 29155511U, 48066738U, 48329913U, 31804017U, 49082993U,\n48533057U, 30731450U, 29420216U, 18642495U, 48794809U, 18184263U, 31461436U, 49313851U,\n49578588U, 48532551U, 18123962U, 24729246U, 25001141U, 25525931U, 31029317U, 32832704U,\n45704831U, 46989952U, 47547060U, 19760223U, 47285832U, 18974793U, 52268229U, 24481986U,\n53318857U, 54106828U, 50962110U, 49913537U, 53582544U, 55157430U, 55682639U, 22915123U,\n47818452U, 42052249U, 44936353U, 42547357U, 40715421U, 56141525U, 42748095U, 50111190U,\n55880407U, 56404519U, 19708610U, 45678181U, 47004831U, 47005313U, 45705395U, 33087159U,\n47234206U, 48029880U, 56714424U, 22899924U, 17075775U, 48294586U, 30994620U, 18708539U,\n49344572U, 45196470U, 23364760U, 56973485U, 33898137U, 47545537U, 44924630U, 48819269U,\n57245822U, 33384064U, 47284931U, 57498799U, 25003198U, 18974404U, 19236941U, 54631112U,\n20997844U, 55163089U, 40217303U, 25511615U, 40218151U, 55918753U, 56208033U, 55879253U,\n50088017U, 56140371U, 13178511U,    25743U, 58046144U, 58309312U, 58543716U, 58834532U,\n46507180U, 56998622U, 45200094U, 58572924U, 44416636U, 59067439U, 49136175U, 39696594U,\n59322434U, 17679426U, 59514894U, 43632142U, 44680870U, 59069606U, 57749144U, 59357336U,\n38814242U, 21080143U, 44679826U, 59843809U, 49137889U, 49079013U, 59864805U, 58771684U,\n60145892U, 58837672U, 32620712U, 46751962U, 48063706U, 55141014U, 39691414U, 38389860U,\n58294490U, 46251226U, 57212087U, 33116270U, 29678760U, 60089000U, 45202608U, 46487728U,\n 8198285U, 34881165U,    73360U,  8126608U, 34933895U, 34671239U, 51480263U, 51742919U,\n20285643U, 52730571U, 50711747U, 60621956U, 24407756U, 54573772U, 14457550U, 53505742U,\n54628445U, 40712811U, 40449643U, 42021535U, 44909214U, 41206891U, 45927549U, 26791549U,\n32820905U, 32570025U, 28425897U, 27318441U, 25216679U, 28360871U, 43892332U, 11322976U,\n58045109U, 32866523U, 45939419U, 47537371U, 58026715U, 45396063U, 24996569U, 45399769U,\n49622194U, 56720050U,  3466917U, 31726245U, 12345977U, 49045113U, 23407805U, 24163005U,\n17136344U, 48530136U, 29969011U, 56717497U, 60891879U, 61149834U, 61460711U, 61986027U,\n61676681U, 62199016U, 61460104U, 61411470U, 62771950U, 63037166U, 63035627U, 63296748U,\n63300842U, 62511858U, 63776405U, 64350357U, 65138422U, 65926393U, 65927418U, 66409619U,\n66975486U, 67502335U, 66971899U, 67241204U, 68284675U, 66713336U, 67503874U, 35195533U,\n36243089U, 36716176U, 36250344U, 38077671U, 61150445U, 63557866U, 61674217U, 62247154U,\n61414635U, 61723375U, 63036657U, 62775531U, 63297776U, 61201134U, 62514417U, 38591125U,\n67708659U, 64242940U, 64574717U, 65390327U, 63777524U, 67970818U, 67503360U, 67757812U,\n68288254U, 67501828U, 67234047U, 68290305U, 66711812U, 54397670U, 53873864U, 68554470U,\n69079816U, 53088461U, 52565253U, 60427974U, 52039370U, 68819211U, 70392587U, 69606152U,\n69082377U, 71179527U, 69867279U, 54927571U, 55452945U, 72755475U, 73543446U, 73805592U,\n74331345U, 73284380U, 75382045U, 71973655U, 75644690U, 72499994U, 73283860U, 74071328U,\n51481291U, 50958543U, 20288206U, 54366469U, 50700006U, 52563210U, 68558599U, 53874950U,\n68556047U, 53088008U, 68817164U, 70130446U, 70654216U, 69606669U, 69864715U, 71177998U,\n47817427U, 54935824U, 20849433U, 57812763U, 59387157U, 55451922U, 54932768U, 75644191U,\n71450898U, 74859292U, 74857761U, 71974685U, 74072862U, 72497441U, 68022518U, 66455286U,\n73282321U, 71970577U, 72493846U, 73279766U, 44690679U, 59593975U, 65140473U, 64876793U,\n65923317U, 66189045U, 59279128U, 72992024U, 17604377U, 73434905U, 59634426U,  4310778U,\n 4322556U,  8921340U, 57787669U, 72202517U, 74069779U, 72496403U, 66397955U, 64301602U,\n55452239U, 74293980U, 53845193U, 53058249U, 35986572U, 37819020U, 37294214U, 37035142U,\n53057221U, 52008133U, 51236039U, 52284614U, 60622983U, 60624520U,  5509130U,  2107966U );\n\nuint getIndex( int faceID, int vertexID )\n{\n    return (faces[faceID] >> (9*vertexID) ) & 511U;\n}\n\nvec3 getVertex( uint id )\n{\n    uint d = vertices[id];\n    vec3 v = vec3(ivec3(d,d>>10,d>>20)&1023) / 1023.0;\n    return v + vec3( -0.0803029,-0.26890646, -0.5770213127 );\n}\n\nvec3 getVertex(int faceID, int vertexID){\n    return getVertex(getIndex(faceID, vertexID));\n}\n","name":"Common","description":"","type":"common"}]},{"ver":"","info":{"id":"","date":"","viewed":0,"name":"new shader","description":"","likes":0,"published":"","tags":[]},"renderpass":[{"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n                    // Normalized pixel coordinates (from 0 to 1)\r\n                    vec2 uv = fragCoord / iResolution.xy;\r\n\r\n            // Time varying pixel color\r\n            vec3 col = 0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0, 2, 4));\r\n\r\n            // Output to screen\r\n            fragColor = vec4(col, 1.0);\r\n        }","name":"","description":"","type":""}]},{"ver":"0.1","info":{"id":"Wtc3RB","date":"0","viewed":0,"name":"Noise-Based Procedural Flame","description":"过程性火焰","likes":0,"published":"Private","tags":["procedural","noise","flame"]},"renderpass":[{"code":"#define CR00 -0.5\n#define CR01 1.5\n#define CR02 -1.5\n#define CR03 0.5\n#define CR10 1.0\n#define CR11 -2.5\n#define CR12 2.0\n#define CR13 -0.5\n#define CR20 -0.5\n#define CR21 0.0\n#define CR22 0.5\n#define CR23 0.0\n#define CR30 0.0\n#define CR31 1.0\n#define CR32 0.0\n#define CR33 0.0\n\nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat spline(float x){  \n    x = clamp(0.0,1.0,x);\n    float nspan = 3.0;\n    float knots[6];\n    knots[0]=1.0;\n    knots[1]=1.0;\n    knots[2]=0.8;\n    knots[3]=0.1;\n    knots[4]=0.0;\n    knots[5]=0.0;\n    \n    x = clamp(0.0,1.0,x)*nspan;\n    float span = floor(x);\n    if(span>=nspan){\n        span = nspan - 1.0;\n    }\n    x -= span;\n    int p0 = int(span);\n    int p1 = int(span+1.0);\n    int p2 = int(span+2.0);\n    int p3 = int(span+3.0);\n    float c3 = CR00*knots[p0] + CR01*knots[p1] + CR02*knots[p2] + CR03*knots[p3];\n    float c2 = CR10*knots[p0] + CR11*knots[p1] + CR12*knots[p2] + CR13*knots[p3];\n    float c1 = CR20*knots[p0] + CR21*knots[p1] + CR22*knots[p2] + CR23*knots[p3];\n    float c0 = CR30*knots[p0] + CR31*knots[p1] + CR32*knots[p2] + CR33*knots[p3];\n    return ((c3*x+c2)*x+c1)*x+c0;\n}\n\nvec3 flame(vec2 p){\n    float anim = iTime*0.2;\n    vec2 t = p;\n    t.y += anim;\n    t.x *= 4.0;\n    t.y *= 2.0;\n    float turb;\n    float a = 1.0;\n    for(int i=0;i<5;i++){\n        turb += a*noise(vec3(t,0));\n        a /= 2.0;\n        //t.x = t.x*2.0*0.866+t.y*2.0*0.5;\n        //t.y = t.x*2.0*(-0.5)+t.y*2.0*(0.866);\n        t.x = t.x*0.866+t.x*0.5;\n        t.y = t.y*(-0.5)+t.y*(-0.866);\n        t *= 2.0;\n    }\n    \n    float flameTemperature = 0.6;\n    vec3 flameColor = vec3(1.0,flameTemperature,flameTemperature-0.2);\n    \n    float turbScale = 0.4 + 0.6*(1.0-p.y);\n    float flameDensity = (1.0/sqrt(p.y))*(abs(2.0*p.x-1.0)+turbScale*turb);\n    flameDensity = 4.5*spline(clamp(0.0,1.0,flameDensity));\n    vec3 color = flameColor*flameDensity;\n    \n    //color = vec3(turb);\n    //color = vec3(edgeDensity);\n    //color = vec3((1.0/sqrt(p.y))*(abs(2.0*p.x-1.0))+turbScale*turb);\n    //color = vec3(flameDensity);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy;\n    p.y = 1.0-p.y;\n    vec3 col = flame(p);\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"3lt3Dr","date":"0","viewed":0,"name":"Procedural 2D Cloud Plane","description":"2d云平面","likes":0,"published":"Private","tags":["procedural2dcloudspectralsynthesis"]},"renderpass":[{"code":"vec3 cloudPlane(vec2 p){\n    vec3 cloudColor = vec3(1.0,1.0,1.0);\n    vec3 skyColor = vec3(135.0/255.0,206.0/255.0,235.0/255.0);\n    float PI = 3.1415926;\n    float offset = 0.5;\n    float x = p.x;\n    float y = p.y;\n    float xphase = 0.9;\n    float yphase = 0.7;\n    float xfreq = 2.0*3.1415926*0.023;\n    float yfreq = 2.0*3.1415926*0.021;\n    float amplitude = 0.3;\n    float f = 0.0;\n    float fx = 0.0;\n    float fy = 0.0;\n    for(float i =0.0;i<5.0;i+=1.0)\n    {\n        fx = amplitude*(offset + cos(xfreq*(x+xphase)));\n        fy = amplitude*(offset+cos(yfreq*(y+yphase)));\n        f += fx*fy;\n        \n        xphase = PI/2.0*0.9*cos(yfreq*y);\n        yphase = PI/2.0*1.1*cos(xfreq*x);\n        xfreq *= 1.9+i*0.1;\n        yfreq *= 2.2-i*0.08;\n        amplitude *= 0.707;\n    }\n    f = clamp(0.0,1.0,f);\n    vec3 col = mix(skyColor,cloudColor,f);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n    vec3 col = cloudPlane(p*30.0+vec2(0,19));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"wlcGRM","date":"1576151122","viewed":50,"name":"Procedural Brick Texture 2D","description":"2D反锯齿砖块贴图","likes":4,"published":"Public","tags":["2d","brick","antialiase"]},"renderpass":[{"code":"#define BRICKWIDTH 0.25\n#define BRICKHEIGHT 0.08\n#define MORTARTHICKNESS 0.01\n\n#define BMWIDTH (BRICKWIDTH+MORTARTHICKNESS)\n#define BMHEIGHT (BRICKHEIGHT+MORTARTHICKNESS)\n\n#define MWF (MORTARTHICKNESS*0.5/BMWIDTH)\n#define MHF (MORTARTHICKNESS*0.5/BMHEIGHT)\n\n#define CBrick vec3(0.5,0.15,0.14)\n#define CMortar vec3(0.5,0.5,0.5)\n\n\n#define frac(x) mod((x),1.0)\n#define sIntegral(s) (floor(s)*(1.0-2.0*MWF)+min(1.0-2.0*MWF,max(0.0,frac(s)-MWF)))\n#define tIntegral(t) (floor(t)*(1.0-2.0*MHF)+min(1.0-2.0*MHF,max(0.0,frac(t)-MHF)))\n\n\nfloat xPixelWidth;\nfloat yPixelWidth;\n\nvec3 brick(vec2 p)\n{\n    float s = p.x/BMWIDTH;\n    float t = p.y/BMHEIGHT;\n    \n    if(mod(floor(t),2.0)==1.0)//奇数行水平偏移半个砖块\n        s += 0.5;\n    //像素点所在砖块编号\n    float sBrick = floor(s);\n    float tBrick = floor(t);\n    ///像素点在砖块内坐标\n    s -= sBrick;\n    t -= tBrick;\n    float w = step(MWF,s) - step(1.0-MWF,t);\n    float h = step(MHF,s) - step(1.0-MHF,t);\n    vec3 col = mix(CMortar, CBrick, w*h);\n    return col;\n}\n\n\nvec3 brickAntialiase(vec2 p){\n    float s = p.x/BMWIDTH;\n    float t = p.y/BMHEIGHT;\n    float ds = xPixelWidth/BMWIDTH;\n    float dt = yPixelWidth/BMHEIGHT;\n    if(mod(floor(t),2.0)==1.0)//奇数行水平偏移半个砖块\n        s += 0.5;\n    ///像素点在砖块内坐标\n    float w = (sIntegral(s+ds)-sIntegral(s))/ds;\n    float h = (tIntegral(t+dt)-tIntegral(t))/dt;\n    vec3 col = mix(CMortar, CBrick, w*h);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy;\n    p = p*2.0-1.0;\n    p.x *= iResolution.x/iResolution.y;\n    \n    float anim = sin(fract(iTime/4.0)*3.1415926);\n    float scale = anim*2.0+0.1;\n    \n    xPixelWidth = yPixelWidth = 2.0/iResolution.y*scale;\n    \n    vec3 col;\n    if(p.x<0.0)\n    {\n        col = brick(p*scale);\n    }else if(p.x>0.0)\n    {\n        col = brickAntialiase(p*scale);\n    }\n   \n    float f = smoothstep(0.0,0.01,abs(p.x));\n    col*=f;\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"3ttGDr","date":"1576051881","viewed":39,"name":"Procedural Five-Point Star","description":"五角星","likes":1,"published":"Public","tags":["procedural","2d","fivepointstar"]},"renderpass":[{"code":"vec3 FivePointStar(vec2 p, vec2 center, float rmin, float rmax, vec3 starColor)\n{\n    float npoints = 5.0;\n    float starAngle = 2.0*3.1415926/npoints;//72度\n    vec3 p0 = rmax*vec3(cos(starAngle/2.0),sin(starAngle/2.0),0.0);\n    vec3 p1 = rmin*vec3(cos(0.0),sin(0.0),0.0);\n    vec3 d = p1-p0;\n    p -= center;\n    float r = sqrt(p.x*p.x+p.y*p.y);\n    float angle = atan(p.y,p.x)+3.1415926-0.28;\n    //根据对称性，每个着色点是否在五角星内可归约为在在某个角(72度)的范围，像素是否其内部\n    //a成为着色点在角中的特征值\n    float a = mod(angle,starAngle)/starAngle;\n    if(a>=0.5)//每个角根据中心到角点的连线对称，因此计算一半就够了\n        a = 1.0-a;\n    vec3 d1 = r*vec3(cos(a*starAngle),sin(a*starAngle),0) - p0;\n    //因此，对于在这个范围内的点，点在五角星内，当且仅当d1在d的右侧\n    float in_out = step(0.0,cross(d,d1).z);\n    vec3 col = mix(starColor, vec3(0.8,0.1,0.1),in_out);\n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = FivePointStar(p,vec2(0.0,0.0),0.25,0.7,vec3(1.0,0.9,0.0));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"code":"vec3 FivePointStar(vec2 p, vec2 center, float rmin, float rmax, vec3 starColor)\n{\n    float npoints = 5.0;\n    float starAngle = 2.0*3.1415926/npoints;//72度\n    vec3 p0 = rmax*vec3(cos(starAngle/2.0),sin(starAngle/2.0),0.0);\n    vec3 p1 = rmin*vec3(cos(0.0),sin(0.0),0.0);\n    vec3 d = p1-p0;\n    p -= center;\n    float r = sqrt(p.x*p.x+p.y*p.y);\n    float angle = atan(p.y,p.x)+3.1415926-0.28;\n    //根据对称性，每个着色点是否在五角星内可归约为在在某个角(72度)的范围，像素是否其内部\n    //a成为着色点在角中的特征值\n    float a = mod(angle,starAngle)/starAngle;\n    if(a>=0.5)//每个角根据中心到角点的连线对称，因此计算一半就够了\n        a = 1.0-a;\n    vec3 d1 = r*vec3(cos(a*starAngle),sin(a*starAngle),0) - p0;\n    //因此，对于在这个范围内的点，点在五角星内，当且仅当d1在d的右侧\n    float in_out = smoothstep(0.0,0.01,cross(d,d1).z);\n    vec3 col = mix(starColor, vec3(0.8,0.1,0.1),in_out);\n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = FivePointStar(p,vec2(0.0,0.0),0.25,0.7,vec3(1.0,0.9,0.0));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"wld3WM","date":"0","viewed":0,"name":"Random Placement Pattern","description":"随机放置五角星","likes":0,"published":"Private","tags":["randomplacement"]},"renderpass":[{"code":"vec3 FivePointStars(vec2 p, float rmin, float rmax, vec3 starColor, vec3 bgColor, int ncells)\n{\n    float npoints = 5.0;\n    float starAngle = 2.0*3.1415926/npoints;//72度\n    \n    float scellctr = floor(p.x*float(ncells));\n    float tcellctr = floor(p.y*float(ncells));\n    float in_out = 0;\n    for(int i = -1;i<=1;i++){\n        for(int j = -1;j<=1;j++){\n            \n        }\n    }\n    \n    vec3 p0 = rmax*vec3(cos(starAngle/2.0),sin(starAngle/2.0),0.0);\n    vec3 p1 = rmin*vec3(cos(0.0),sin(0.0),0.0);\n    vec3 d = p1-p0;\n    p -= center;\n    float r = sqrt(p.x*p.x+p.y*p.y);\n    float angle = atan(p.y,p.x)+3.1415926-0.28;\n    //根据对称性，每个着色点是否在五角星内可归约为在在某个角(72度)的范围，像素是否其内部\n    //a成为着色点在角中的特征值\n    float a = mod(angle,starAngle)/starAngle;\n    if(a>=0.5)//每个角根据中心到角点的连线对称，因此计算一半就够了\n        a = 1.0-a;\n    vec3 d1 = r*vec3(cos(a*starAngle),sin(a*starAngle),0) - p0;\n    //因此，对于在这个范围内的点，点在五角星内，当且仅当d1在d的右侧\n    float in_out = smoothstep(0.0,0.01,cross(d,d1).z);\n    vec3 col = mix(starColor, bgColor, in_out);\n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = FivePointStar(p,vec2(0.0,0.0),0.25,0.7,vec3(1.0,0.9,0.0));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"wllXWH","date":"0","viewed":0,"name":"Raymarch in Raymarch","description":"Raymarch tutorial","likes":0,"published":"Private","tags":["raymarch"]},"renderpass":[{"code":"#define MAT_SCREEN 0.\n#define MAT_SPHERE1 1.\n#define MAT_FLOOR  2.\n#define MAT_CORNER 3.\n#define MAT_SCREENZ 4.\n#define MAT_MARCHSPHERE 5.\n#define MAT_MARCHROUTE 6.\n#define MAT_MARCHRADIUS 7.\n#define MAT_SPHERE2 8.\n#define MAT_SPHERE3 9.\n#define MAT_RAYDIRECTION 10.\n#define MAT_HITPOINT 11.\n\nfloat uvToP = 0.0;\nfloat colToUv = 1.0;\nfloat screenZ = 2.5;\n\nfloat sphereAnim = 1.0;\nfloat radiusAnim = 1.0;\nfloat routeAnim = 1.0;\n\nfloat raySphereAlpha = 0.0;\n\nfloat cornersAlpha = 0.0;\nfloat cornersAnim = 0.0;\n\nfloat screenZAlpha = 0.0;\n\nfloat radiusAlpha = 1.0;\n\nfloat rayDirectionAnim = 0.0;\nfloat rayDirectionAnim2 = 0.0;\n\nfloat screenAlpha = 0.0;\n\n// =====================Camera========================\nvec3 cameraPos, cameraTarget;\n\n//================================\n\nfloat sum = 0.0;\n\nfloat tl(float val, float offset, float range)\n{\n    float im = sum + offset;\n    float ix = im + range;\n    sum += offset + range;\n    return clamp((val - im) / (ix - im), 0.0, 1.0);\n}\n\nfloat cio(float t) {\n\treturn t < 0.5\n\t? 0.5 * (1.0 - sqrt(1.0 - 4.0 * t * t))\n\t: 0.5 * (sqrt((3.0 - 2.0 * t) * (2.0 * t - 1.0)) + 1.0);\n}\n\nfloat eio(float t) {\n\treturn t == 0.0 || t == 1.0\n\t\t? t\n\t\t: t < 0.5\n\t\t? +0.5 * pow(2.0, (20.0 * t) - 10.0)\n\t\t: -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;\n}\n\nvoid timeLine(float time)\n{\n    //time += 32.;\n    float t = tl(time, 1.0, 0.5);\n    uvToP = mix(0.0, 1.0, eio(t));\n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(vec3(0.0), vec3(5., 5., -2.), eio(t));\n    cameraTarget = vec3(0.0, 0.0, 5.);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    raySphereAlpha = mix(0., 1., t);\n    cornersAlpha = mix(0., 1., t);\n    \n    t = tl(time, 0.5, 1.0);\n    cornersAnim = mix(0., 1., t);\n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(cameraPos, vec3(2., 3., -3.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 3.0), eio(t));\n    \n    t = tl(time, 0.5, 0.5);\n    screenZAlpha = mix(0., 1., t);\n\n\tt = tl(time, 0.5, .5);\n    colToUv = mix(colToUv, 0.0, eio(t));\n    \n    t = tl(time, 0.5, 1.0);\n    screenZ = mix(screenZ, 5.0, eio(t));\n    \n    t = tl(time, 1.0, 1.0);\n    screenZ = mix(screenZ, .75, eio(t));\n    \n    \n    t = tl(time, 1.0, 1.0);\n    screenZ = mix(screenZ, 2.5, eio(t));\n    \n    \n    t = tl(time, 0.5, 1.0);\n    cornersAlpha = mix(cornersAlpha, 0., t);\n    screenZAlpha = mix(screenZAlpha, 0., t);\n    colToUv = mix(colToUv, 1.0, eio(t));\n    \n    t = tl(time, 0.0, 0.0);\n    cornersAnim = mix(cornersAnim, 0., t);\n    \n    t = tl(time, 0.5, 1.0);\n    cameraPos = mix(cameraPos, vec3(5., 15., 6.0), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 6.), eio(t));\n    \n    for (int i=0; i<6; i++) {\n        t = tl(time, 0.25, 0.25);\n        radiusAnim = mix(radiusAnim, float(i) + 2., t);\n        t = tl(time, 0.25, 0.25);\n        routeAnim = mix(routeAnim, float(i) + 2., t);\n        t = tl(time, 0.25, 0.25);\n        sphereAnim = mix(sphereAnim, float(i) + 2., t);\n    }\n    \n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(cameraPos, vec3(2., 3., -3.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 3.0), eio(t));\n    radiusAlpha = mix(radiusAlpha, 0.0, t);\n    routeAnim = mix(routeAnim, 1.0, t);\n    sphereAnim = mix(sphereAnim, 1.0, t);\n    colToUv = mix(colToUv, 1.0, eio(t));\n    screenAlpha = mix(screenAlpha, 0.0, t);\n    \n    t = tl(time, 0.5, 1.0);\n    rayDirectionAnim2 = mix(rayDirectionAnim2, 1.0, eio(t));\n    \n    t = tl(time, 0.5, 4.0);\n    rayDirectionAnim = mix(rayDirectionAnim, 1.0, t);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    raySphereAlpha = mix(raySphereAlpha, 0.0, t);\n    rayDirectionAnim2 = mix(rayDirectionAnim2, 0.0, t);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    cameraPos = mix(cameraPos, vec3(0.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 5.), eio(t));\n}\n\nvec2 opU(vec2 a, vec2 b)\n{\n    return a.x < b.x ? a : b;\n}\n\nfloat sdLine( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\nvec3 sunDir = normalize(vec3(.3, .25, .2));\nvec3 skyColor(vec3 rd)\n{\n    float sundot = clamp(dot(rd,sunDir),0.0,1.0);\n    // sky\t\t\n    vec3 col = mix(vec3(0.2,0.5,0.85)*1.1, vec3(0.0,0.15,0.7), rd.y);\n    col = mix( col, 0.85*vec3(0.8,0.8,0.7), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n    // sun\n    col += 0.3*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n    col += 0.5*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n    col += 6.0*vec3(1.0,0.8,0.6)*pow( sundot,1024.0 );\n    return col * 3.0;\n}\n\nvec3 screenPos;\n\nvec2 sceneSpheres(vec3 p)\n{\n    vec2 s1 = vec2(sdSphere(p - vec3(-2.0, 0.0, 6.0), 1.), MAT_SPHERE1);\n    vec2 s2 = vec2(sdSphere(p - vec3(0.0, 0.0, 12.0), 1.), MAT_SPHERE2);\n    vec2 s3 = vec2(sdSphere(p - vec3(2.0, 0.0, 9.0), 1.), MAT_SPHERE3);\n    return opU(opU(s1, s2), s3);\n}\n\nvec2 sceneMap(vec3 p)\n{\n    vec2 s = sceneSpheres(p);\n    vec2 p1 = vec2(p.y + 2.0, MAT_FLOOR);\n    return opU(s, p1);\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(0.001, 0.0);\n    float d = sceneMap(p).x;\n    return normalize(d - vec3(sceneMap(p - e.xyy).x, sceneMap(p - e.yxy).x, sceneMap(p - e.yyx).x));\n}\n\nvoid sceneTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 70; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = sceneMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nvec2 screenMap(vec3 p)\n{\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    vec2 b1 = vec2(sdBox(p - vec3(0., 0., screenZ), vec3(screenSize, 0.01)), MAT_SCREEN);\n    return b1;\n}\n\nvoid screenTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 20; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = screenMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nfloat remap(float val, float im, float ix, float om, float ox)\n{\n    return clamp(om + (val - im) * (ox - om) / (ix - im), om, ox);\n}\n\nvec2 gizmoCorners(vec3 p)\n{\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    \n    float a1 = remap(cornersAnim, 0.0, 0.25, 0.0, 1.0);\n    float a2 = remap(cornersAnim, 0.25, 0.5, 0.0, 1.0);\n    float a3 = remap(cornersAnim, 0.5, 0.75, 0.0, 1.0);\n    float a4 = remap(cornersAnim, 0.75, 1.0, 0.0, 1.0);\n    \n    vec2 c1 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize, screenZ), a1), 0.02), MAT_CORNER);\n    vec2 c2 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(1.,-1.), screenZ), a2), 0.02), MAT_CORNER);\n    vec2 c3 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(-1.,-1.), screenZ), a3), 0.02), MAT_CORNER);\n    vec2 c4 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(-1.,1.), screenZ), a4), 0.02), MAT_CORNER);\n    return opU(c1, opU(c2, opU(c3, c4)));\n}\n\nvec2 gizmoScreenZ(vec3 p)\n{\n    vec2 c1 = vec2(sdLine(p, vec3(0.), vec3(0., 0., screenZ), 0.03), MAT_SCREENZ);\n    return c1;\n}\n\nfloat sphereID = 0.0;\nvec2 gizmoMarching(vec3 p)\n{\n    vec3 ray = vec3(0., 0., 1.);\n    vec2 d = vec2(10000.);\n    \n    float t = 0.0;\n    for(int i=0; i<7; i++) {\n    \tvec3 pos = ray * t;\n        vec2 s = vec2(sdSphere(p - pos, 0.15), MAT_MARCHSPHERE);\n        if (s.x < d.x) {\n            d = s;\n            sphereID = float(i);\n        }\n        \n        float dist = sceneSpheres(pos).x;\n        \n        float anim = clamp(routeAnim - float(i) - 1., 0.0, 1.0);\n        vec2 c1 = vec2(sdLine(p, pos, pos + mix(vec3(0.), ray * dist, anim), 0.03), MAT_MARCHROUTE);\n        \n        d = opU(d, c1);\n        t += dist;\n    }\n    return d;\n}\n\nvec2 gizmoMarchingRadius(vec3 p)\n{\n    vec2 d = vec2(p.y, MAT_MARCHRADIUS);\n    return d;\n}\n\n\nvec2 gizmoRayDirection(vec3 p)\n{\n    float a1 = fract(rayDirectionAnim * 19.99999);\n    float a2 = floor(rayDirectionAnim * 19.99999) / 20.;\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    screenSize.y *= -1.;\n    screenSize = mix(-screenSize, screenSize, vec2(a1, a2));\n    vec2 c1 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize, screenZ) * 10.0, rayDirectionAnim2), 0.02), MAT_RAYDIRECTION);\n    \n    vec3 ray = normalize(vec3(screenSize, screenZ));\n    vec3 pos;\n    float t = 0.01;\n    for(int i = 0; i < 20; i++) {\n    \tpos = ray * t;\n        vec2 d = sceneMap(pos);\n        t += d.x;\n    }\n    \n    c1 = opU(c1, vec2(sdSphere(p - pos, 0.3), MAT_HITPOINT));\n    \n    return c1;\n}\n\nvec2 gizmoMap(vec3 p)\n{\n    vec2 d = opU(gizmoCorners(p), gizmoScreenZ(p));\n    d = opU(d, gizmoMarching(p));\n    d = opU(d, gizmoRayDirection(p));\n    return d;\n}\n\nvoid gizmoTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 60; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = gizmoMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nvec2 radiusMap(vec3 p)\n{\n    return gizmoMarchingRadius(p);\n}\n\nvoid radiusTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 40; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = radiusMap(pos);\n        if (mat.x < 0.001 || depth > maxD) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nfloat shadow(in vec3 p, in vec3 l, float ma)\n{\n    float t = 0.1;\n    float t_max = ma;\n    \n    float res = 1.0;\n    for (int i = 0; i < 16; ++i)\n    {\n        if (t > t_max) break;\n        vec3 pos = p + t*l;\n        float d = opU(sceneMap(pos), screenMap(pos)).x;\n        if (d < 0.001)\n        {\n            return 0.0;\n        }\n        t += d*1.0;\n        res = min(res, 10.0 * d / t);\n    }\n    \n    return res;\n}\n\n// checkerbord\n// https://www.shadertoy.com/view/XlcSz2\nfloat checkersTextureGradBox( in vec2 p, in vec2 ddx, in vec2 ddy )\n{\n    // filter kernel\n    vec2 w = max(abs(ddx), abs(ddy)) + 0.01;  \n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)/2.0)-0.5)-abs(fract((p+0.5*w)/2.0)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 sceneShade(vec2 mat, vec3 pos, vec3 ray, float depth, float maxD)\n{\n    vec3 col;\n    vec3 sky = skyColor(ray);\n    if (depth > maxD - 0.01) {\n    \treturn sky;\n    }\n    float sha = shadow(pos, sunDir, 10.);\n    vec3 norm = normal(pos);\n    vec3 albedo = vec3(0.);\n    if(mat.y == MAT_SPHERE1) {\n        albedo = vec3(1., 0., 0.);\n    } else if (mat.y == MAT_SPHERE2) {\n        albedo = vec3(0., 1., 0.);\n    } else if (mat.y == MAT_SPHERE3) {\n        albedo = vec3(0., 0., 1.);\n    } else if(mat.y == MAT_FLOOR) {\n        vec2 ddx_uvw = dFdx( pos.xz ); \n        vec2 ddy_uvw = dFdy( pos.xz ); \n        float checker = checkersTextureGradBox( pos.xz, ddy_uvw, ddy_uvw );\n        albedo = vec3(max(0.2, checker)) * vec3(.8,0.8,0.7) * 2.0;\n    }\n    \n    float diffuse = clamp(dot(norm, sunDir), 0.0, 1.0) * sha * 2.0;\n    col = albedo * (diffuse + 0.05);\n    \n    float fo = 1.0 - exp2(-0.0001 * depth * depth);\n    vec3 fco = 0.65*vec3(0.4,0.65,1.0);\n    col = mix( col, sky, fo );\n    return col;\n}\n\nvec3 screenShade(vec2 mat, vec3 pos)\n{\n    vec3 ro = vec3(0., 0., 0.);\n    vec3 ta = vec3(0., 0., 3.);\n    vec3 fo = normalize(ta - ro);\n    vec3 ri = normalize(cross(vec3(0.,1.,0.), fo));\n    vec3 up = normalize(cross(fo,ri));\n    mat3 cam = mat3(ri,up,fo);\n    vec3 ray = cam * normalize(pos);\n    float depth = 0.01;\n    vec3 p = ro;\n    sceneTrace(p, ray, mat, depth, 100.);\n    vec3 col = vec3(0.);\n    col = sceneShade(mat, p, ray, depth, 100.);\n    \n    float a1 = fract(rayDirectionAnim * 19.99999);\n    float a2 = floor(rayDirectionAnim * 19.99999 + 1.0) / 20.;\n    float a3 = floor(rayDirectionAnim * 19.99999) / 20.;\n    \n    float aspect = iResolution.y / iResolution.x;\n    float halfAspect = aspect * 0.5;\n    \n    a1 = step(pos.x * halfAspect + 0.5, a1);\n    a2 = step(-pos.y * 0.49 + 0.51+ 0.0, a2);\n    a3 = step(-pos.y * 0.49 + 0.51 + 0.0, a3);\n    //col *= min(screenAlpha + min(a2 * a1 + a3, 1.0), 1.0);\n    \n    vec3 uvCoord = vec3(pow(clamp(mix(pos.xy*0.5+0.5, pos.xy, uvToP), 0.0, 1.0), vec2(2.2)), 0.0);\n    col = mix(col, uvCoord, colToUv - min(screenAlpha + min(a2 * a1 + a3, 1.0), 1.0));\n    return col;\n    //return vec3(pow(clamp(pos.xy, 0.0, 1.0), vec2(2.2)), 0.0);\n}\n\nvec4 gizmoShade(vec2 mat, vec3 p)\n{\n    vec4 col = vec4(0.);\n\n    if(mat.y == MAT_CORNER) {\n        col = vec4(1.,0.,0., cornersAlpha);\n    } else if (mat.y == MAT_SCREENZ) {\n    \tcol = vec4(0.05, 0.05, 1., screenZAlpha);\n    } else if (mat.y == MAT_MARCHSPHERE) {\n        float alpha = clamp(sphereAnim - sphereID, 0.0, 1.0);\n        vec3 sc = mix(vec3(.0, .1, 3.), vec3(.02, 1., .02), float(sphereID == 0. || sphereID == 6.));\n    \tcol = vec4(sc, alpha * raySphereAlpha);\n    } else if (mat.y == MAT_MARCHROUTE) {\n        col = vec4(1., 0., 0., .9);\n    } else if (mat.y == MAT_RAYDIRECTION) {\n        col = vec4(1., 0., 0., .9);\n    } else if (mat.y == MAT_HITPOINT) {\n    \tcol = vec4(.02, 1., .02, raySphereAlpha);\n    }\n    return col;\n}\n\nvec4 radiusShade(vec2 mat, vec3 p)\n{\n    vec4 col = vec4(0.);\n\n    vec3 ray = vec3(0., 0., 1.);\n    vec2 d = vec2(10000.);\n\n    float t = 0.0;\n    for(int i=0; i<7; i++) {\n        vec3 pos = ray * t;\n        vec2 dd = sceneSpheres(pos);\n        d = vec2(sdSphere(p - pos, dd.x), MAT_MARCHSPHERE);\n        float alpha2 = step(radiusAnim, float(i) + 2.);\n        float alpha = clamp(radiusAnim - float(i) - 1., 0.0, 1.0);\n        \n        vec4 cirCol = mix(vec4(.0, 0.05, 0.1, 0.9), vec4(0.2, 1., 1.4, .6) , alpha2);\n        col = mix(col, cirCol, smoothstep(0.01, 0., d.x) * cirCol.a * alpha);\n        col = mix(col, vec4(0., 0., 0., 1.), smoothstep(0.02, 0., abs(d.x) - 0.01) * alpha);\n        t += dd.x;\n    }\n    col *= radiusAlpha;\n    return col;\n}\n\nfloat luminance(vec3 col)\n{\n    return dot(vec3(0.298912, 0.586611, 0.114478), col);\n}\n\nvec3 reinhard(vec3 col, float exposure, float white) {\n    col *= exposure;\n    white *= exposure;\n    float lum = luminance(col);\n    return (col * (lum / (white * white) + 1.0) / (lum + 1.0));\n}\n\nvec3 render(vec2 p) {\n    screenPos = vec3(p, 2.5);\n    vec3 ro = cameraPos;\n    vec3 ta = cameraTarget;\n    vec3 fo = normalize(ta - ro);\n    vec3 ri = normalize(cross(vec3(0.,1.,0.), fo));\n    vec3 up = normalize(cross(fo,ri));\n    mat3 cam = mat3(ri,up,fo);\n    vec3 ray = cam * normalize(screenPos);\n    float depth = 0.01;\n    vec2 mat;\n    vec3 col = vec3(0.);\n    \n    vec3 pos = ro;\n    sceneTrace(pos, ray, mat, depth, 100.);\n    \n    col = sceneShade(mat, pos, ray, depth, 100.);\n    \n    float sceneDepth = depth;\n    depth = 0.01;\n    pos = ro;\n    screenTrace(pos, ray, mat, depth, sceneDepth);\n    if (depth < sceneDepth) {\n        col = screenShade(mat, pos);\n    }\n    \n    float sceneAndScreenDepth = depth;\n    depth = 0.01;\n    pos = ro;\n    radiusTrace(pos, ray, mat, depth, sceneAndScreenDepth);\n    if (depth < sceneAndScreenDepth) {\n        vec4 radius = radiusShade(mat, pos);\n        col = mix(col, radius.rgb, radius.a);\n    }\n    \n    float sceneAndScreenAndGizmoDepth = sceneAndScreenDepth;\n    depth = 0.01;\n    pos = ro;\n    gizmoTrace(pos, ray, mat, depth, sceneAndScreenAndGizmoDepth);\n    if (depth < sceneAndScreenAndGizmoDepth) {\n        vec4 gizmo = gizmoShade(mat, pos);\n        col = mix(col, gizmo.rgb, gizmo.a);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    timeLine(mod(iTime, 41.));\n\n    vec2 p = (fragCoord * 2.0 - iResolution.xy)/min(iResolution.x, iResolution.y);\n    vec2 dp = 1. / iResolution.xy;\n\n    vec3 col = vec3(0.);\n    \n    \n    // AA\n    // https://www.shadertoy.com/view/Msl3Rr\n    for(int y = 0; y < 2; y++) {\n        for(int x = 0; x < 2; x++) {\n            vec2 off = vec2(float(x),float(y))/2.;\n            vec2 xy = (-iResolution.xy+2.0*(fragCoord+off)) / iResolution.y;\n        \tcol += render(xy)*0.25;\n        }\n    }\n    \n    col = reinhard(col, 1.0, 1000.0);\n    col = pow(col, vec3(1.0/2.2));\n    \n    //col = mix(col, vec3(mix(uv, p, uvToP), 0.), colToUv);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"3stXDH","date":"0","viewed":0,"name":"RayMarch 原理","description":"RayMarch","likes":0,"published":"Private","tags":["raymarch"]},"renderpass":[{"code":"#define MAT_SCREEN 0.\n#define MAT_SPHERE1 1.\n#define MAT_FLOOR  2.\n#define MAT_CORNER 3.\n#define MAT_SCREENZ 4.\n#define MAT_MARCHSPHERE 5.\n#define MAT_MARCHROUTE 6.\n#define MAT_MARCHRADIUS 7.\n#define MAT_SPHERE2 8.\n#define MAT_SPHERE3 9.\n#define MAT_RAYDIRECTION 10.\n#define MAT_HITPOINT 11.\n\nfloat uvToP = 0.0;\nfloat colToUv = 1.0;\nfloat screenZ = 2.5;\n\nfloat sphereAnim = 1.0;\nfloat radiusAnim = 1.0;\nfloat routeAnim = 1.0;\n\nfloat raySphereAlpha = 0.0;\n\nfloat cornersAlpha = 0.0;\nfloat cornersAnim = 0.0;\n\nfloat screenZAlpha = 0.0;\n\nfloat radiusAlpha = 1.0;\n\nfloat rayDirectionAnim = 0.0;\nfloat rayDirectionAnim2 = 0.0;\n\nfloat screenAlpha = 0.0;\n\n// =====================Camera========================\nvec3 cameraPos, cameraTarget;\n\n//================================\n\nfloat sum = 0.0;\n\nfloat tl(float val, float offset, float range)\n{\n    float im = sum + offset;\n    float ix = im + range;\n    sum += offset + range;\n    return clamp((val - im) / (ix - im), 0.0, 1.0);\n}\n\nfloat cio(float t) {\n\treturn t < 0.5\n\t? 0.5 * (1.0 - sqrt(1.0 - 4.0 * t * t))\n\t: 0.5 * (sqrt((3.0 - 2.0 * t) * (2.0 * t - 1.0)) + 1.0);\n}\n\nfloat eio(float t) {\n\treturn t == 0.0 || t == 1.0\n\t\t? t\n\t\t: t < 0.5\n\t\t? +0.5 * pow(2.0, (20.0 * t) - 10.0)\n\t\t: -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;\n}\n\nvoid timeLine(float time)\n{\n    //time += 32.;\n    float t = tl(time, 1.0, 0.5);\n    uvToP = mix(0.0, 1.0, eio(t));\n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(vec3(0.0), vec3(5., 5., -2.), eio(t));\n    cameraTarget = vec3(0.0, 0.0, 5.);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    raySphereAlpha = mix(0., 1., t);\n    cornersAlpha = mix(0., 1., t);\n    \n    t = tl(time, 0.5, 1.0);\n    cornersAnim = mix(0., 1., t);\n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(cameraPos, vec3(2., 3., -3.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 3.0), eio(t));\n    \n    t = tl(time, 0.5, 0.5);\n    screenZAlpha = mix(0., 1., t);\n\n\tt = tl(time, 0.5, .5);\n    colToUv = mix(colToUv, 0.0, eio(t));\n    \n    t = tl(time, 0.5, 1.0);\n    screenZ = mix(screenZ, 5.0, eio(t));\n    \n    t = tl(time, 1.0, 1.0);\n    screenZ = mix(screenZ, .75, eio(t));\n    \n    \n    t = tl(time, 1.0, 1.0);\n    screenZ = mix(screenZ, 2.5, eio(t));\n    \n    \n    t = tl(time, 0.5, 1.0);\n    cornersAlpha = mix(cornersAlpha, 0., t);\n    screenZAlpha = mix(screenZAlpha, 0., t);\n    colToUv = mix(colToUv, 1.0, eio(t));\n    \n    t = tl(time, 0.0, 0.0);\n    cornersAnim = mix(cornersAnim, 0., t);\n    \n    t = tl(time, 0.5, 1.0);\n    cameraPos = mix(cameraPos, vec3(5., 15., 6.0), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 6.), eio(t));\n    \n    for (int i=0; i<6; i++) {\n        t = tl(time, 0.25, 0.25);\n        radiusAnim = mix(radiusAnim, float(i) + 2., t);\n        t = tl(time, 0.25, 0.25);\n        routeAnim = mix(routeAnim, float(i) + 2., t);\n        t = tl(time, 0.25, 0.25);\n        sphereAnim = mix(sphereAnim, float(i) + 2., t);\n    }\n    \n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(cameraPos, vec3(2., 3., -3.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 3.0), eio(t));\n    radiusAlpha = mix(radiusAlpha, 0.0, t);\n    routeAnim = mix(routeAnim, 1.0, t);\n    sphereAnim = mix(sphereAnim, 1.0, t);\n    colToUv = mix(colToUv, 1.0, eio(t));\n    screenAlpha = mix(screenAlpha, 0.0, t);\n    \n    t = tl(time, 0.5, 1.0);\n    rayDirectionAnim2 = mix(rayDirectionAnim2, 1.0, eio(t));\n    \n    t = tl(time, 0.5, 4.0);\n    rayDirectionAnim = mix(rayDirectionAnim, 1.0, t);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    raySphereAlpha = mix(raySphereAlpha, 0.0, t);\n    rayDirectionAnim2 = mix(rayDirectionAnim2, 0.0, t);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    cameraPos = mix(cameraPos, vec3(0.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 5.), eio(t));\n}\n\nvec2 opU(vec2 a, vec2 b)\n{\n    return a.x < b.x ? a : b;\n}\n\nfloat sdLine( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\nvec3 sunDir = normalize(vec3(.3, .25, .2));\nvec3 skyColor(vec3 rd)\n{\n    float sundot = clamp(dot(rd,sunDir),0.0,1.0);\n    // sky\t\t\n    vec3 col = mix(vec3(0.2,0.5,0.85)*1.1, vec3(0.0,0.15,0.7), rd.y);\n    col = mix( col, 0.85*vec3(0.8,0.8,0.7), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n    // sun\n    col += 0.3*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n    col += 0.5*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n    col += 6.0*vec3(1.0,0.8,0.6)*pow( sundot,1024.0 );\n    return col * 3.0;\n}\n\nvec3 screenPos;\n\nvec2 sceneSpheres(vec3 p)\n{\n    vec2 s1 = vec2(sdSphere(p - vec3(-2.0, 0.0, 6.0), 1.), MAT_SPHERE1);\n    vec2 s2 = vec2(sdSphere(p - vec3(0.0, 0.0, 12.0), 1.), MAT_SPHERE2);\n    vec2 s3 = vec2(sdSphere(p - vec3(2.0, 0.0, 9.0), 1.), MAT_SPHERE3);\n    return opU(opU(s1, s2), s3);\n}\n\nvec2 sceneMap(vec3 p)\n{\n    vec2 s = sceneSpheres(p);\n    vec2 p1 = vec2(p.y + 2.0, MAT_FLOOR);\n    return opU(s, p1);\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(0.001, 0.0);\n    float d = sceneMap(p).x;\n    return normalize(d - vec3(sceneMap(p - e.xyy).x, sceneMap(p - e.yxy).x, sceneMap(p - e.yyx).x));\n}\n\nvoid sceneTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 70; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = sceneMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nvec2 screenMap(vec3 p)\n{\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    vec2 b1 = vec2(sdBox(p - vec3(0., 0., screenZ), vec3(screenSize, 0.01)), MAT_SCREEN);\n    return b1;\n}\n\nvoid screenTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 20; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = screenMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nfloat remap(float val, float im, float ix, float om, float ox)\n{\n    return clamp(om + (val - im) * (ox - om) / (ix - im), om, ox);\n}\n\nvec2 gizmoCorners(vec3 p)\n{\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    \n    float a1 = remap(cornersAnim, 0.0, 0.25, 0.0, 1.0);\n    float a2 = remap(cornersAnim, 0.25, 0.5, 0.0, 1.0);\n    float a3 = remap(cornersAnim, 0.5, 0.75, 0.0, 1.0);\n    float a4 = remap(cornersAnim, 0.75, 1.0, 0.0, 1.0);\n    \n    vec2 c1 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize, screenZ), a1), 0.02), MAT_CORNER);\n    vec2 c2 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(1.,-1.), screenZ), a2), 0.02), MAT_CORNER);\n    vec2 c3 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(-1.,-1.), screenZ), a3), 0.02), MAT_CORNER);\n    vec2 c4 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(-1.,1.), screenZ), a4), 0.02), MAT_CORNER);\n    return opU(c1, opU(c2, opU(c3, c4)));\n}\n\nvec2 gizmoScreenZ(vec3 p)\n{\n    vec2 c1 = vec2(sdLine(p, vec3(0.), vec3(0., 0., screenZ), 0.03), MAT_SCREENZ);\n    return c1;\n}\n\nfloat sphereID = 0.0;\nvec2 gizmoMarching(vec3 p)\n{\n    vec3 ray = vec3(0., 0., 1.);\n    vec2 d = vec2(10000.);\n    \n    float t = 0.0;\n    for(int i=0; i<7; i++) {\n    \tvec3 pos = ray * t;\n        vec2 s = vec2(sdSphere(p - pos, 0.15), MAT_MARCHSPHERE);\n        if (s.x < d.x) {\n            d = s;\n            sphereID = float(i);\n        }\n        \n        float dist = sceneSpheres(pos).x;\n        \n        float anim = clamp(routeAnim - float(i) - 1., 0.0, 1.0);\n        vec2 c1 = vec2(sdLine(p, pos, pos + mix(vec3(0.), ray * dist, anim), 0.03), MAT_MARCHROUTE);\n        \n        d = opU(d, c1);\n        t += dist;\n    }\n    return d;\n}\n\nvec2 gizmoMarchingRadius(vec3 p)\n{\n    vec2 d = vec2(p.y, MAT_MARCHRADIUS);\n    return d;\n}\n\n\nvec2 gizmoRayDirection(vec3 p)\n{\n    float a1 = fract(rayDirectionAnim * 19.99999);\n    float a2 = floor(rayDirectionAnim * 19.99999) / 20.;\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    screenSize.y *= -1.;\n    screenSize = mix(-screenSize, screenSize, vec2(a1, a2));\n    vec2 c1 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize, screenZ) * 10.0, rayDirectionAnim2), 0.02), MAT_RAYDIRECTION);\n    \n    vec3 ray = normalize(vec3(screenSize, screenZ));\n    vec3 pos;\n    float t = 0.01;\n    for(int i = 0; i < 20; i++) {\n    \tpos = ray * t;\n        vec2 d = sceneMap(pos);\n        t += d.x;\n    }\n    \n    c1 = opU(c1, vec2(sdSphere(p - pos, 0.3), MAT_HITPOINT));\n    \n    return c1;\n}\n\nvec2 gizmoMap(vec3 p)\n{\n    vec2 d = opU(gizmoCorners(p), gizmoScreenZ(p));\n    d = opU(d, gizmoMarching(p));\n    d = opU(d, gizmoRayDirection(p));\n    return d;\n}\n\nvoid gizmoTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 60; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = gizmoMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nvec2 radiusMap(vec3 p)\n{\n    return gizmoMarchingRadius(p);\n}\n\nvoid radiusTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 40; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = radiusMap(pos);\n        if (mat.x < 0.001 || depth > maxD) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nfloat shadow(in vec3 p, in vec3 l, float ma)\n{\n    float t = 0.1;\n    float t_max = ma;\n    \n    float res = 1.0;\n    for (int i = 0; i < 16; ++i)\n    {\n        if (t > t_max) break;\n        vec3 pos = p + t*l;\n        float d = opU(sceneMap(pos), screenMap(pos)).x;\n        if (d < 0.001)\n        {\n            return 0.0;\n        }\n        t += d*1.0;\n        res = min(res, 10.0 * d / t);\n    }\n    \n    return res;\n}\n\n// checkerbord\n// https://www.shadertoy.com/view/XlcSz2\nfloat checkersTextureGradBox( in vec2 p, in vec2 ddx, in vec2 ddy )\n{\n    // filter kernel\n    vec2 w = max(abs(ddx), abs(ddy)) + 0.01;  \n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)/2.0)-0.5)-abs(fract((p+0.5*w)/2.0)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 sceneShade(vec2 mat, vec3 pos, vec3 ray, float depth, float maxD)\n{\n    vec3 col;\n    vec3 sky = skyColor(ray);\n    if (depth > maxD - 0.01) {\n    \treturn sky;\n    }\n    float sha = shadow(pos, sunDir, 10.);\n    vec3 norm = normal(pos);\n    vec3 albedo = vec3(0.);\n    if(mat.y == MAT_SPHERE1) {\n        albedo = vec3(1., 0., 0.);\n    } else if (mat.y == MAT_SPHERE2) {\n        albedo = vec3(0., 1., 0.);\n    } else if (mat.y == MAT_SPHERE3) {\n        albedo = vec3(0., 0., 1.);\n    } else if(mat.y == MAT_FLOOR) {\n        vec2 ddx_uvw = dFdx( pos.xz ); \n        vec2 ddy_uvw = dFdy( pos.xz ); \n        float checker = checkersTextureGradBox( pos.xz, ddy_uvw, ddy_uvw );\n        albedo = vec3(max(0.2, checker)) * vec3(.8,0.8,0.7) * 2.0;\n    }\n    \n    float diffuse = clamp(dot(norm, sunDir), 0.0, 1.0) * sha * 2.0;\n    col = albedo * (diffuse + 0.05);\n    \n    float fo = 1.0 - exp2(-0.0001 * depth * depth);\n    vec3 fco = 0.65*vec3(0.4,0.65,1.0);\n    col = mix( col, sky, fo );\n    return col;\n}\n\nvec3 screenShade(vec2 mat, vec3 pos)\n{\n    vec3 ro = vec3(0., 0., 0.);\n    vec3 ta = vec3(0., 0., 3.);\n    vec3 fo = normalize(ta - ro);\n    vec3 ri = normalize(cross(vec3(0.,1.,0.), fo));\n    vec3 up = normalize(cross(fo,ri));\n    mat3 cam = mat3(ri,up,fo);\n    vec3 ray = cam * normalize(pos);\n    float depth = 0.01;\n    vec3 p = ro;\n    sceneTrace(p, ray, mat, depth, 100.);\n    vec3 col = vec3(0.);\n    col = sceneShade(mat, p, ray, depth, 100.);\n    \n    float a1 = fract(rayDirectionAnim * 19.99999);\n    float a2 = floor(rayDirectionAnim * 19.99999 + 1.0) / 20.;\n    float a3 = floor(rayDirectionAnim * 19.99999) / 20.;\n    \n    float aspect = iResolution.y / iResolution.x;\n    float halfAspect = aspect * 0.5;\n    \n    a1 = step(pos.x * halfAspect + 0.5, a1);\n    a2 = step(-pos.y * 0.49 + 0.51+ 0.0, a2);\n    a3 = step(-pos.y * 0.49 + 0.51 + 0.0, a3);\n    //col *= min(screenAlpha + min(a2 * a1 + a3, 1.0), 1.0);\n    \n    vec3 uvCoord = vec3(pow(clamp(mix(pos.xy*0.5+0.5, pos.xy, uvToP), 0.0, 1.0), vec2(2.2)), 0.0);\n    col = mix(col, uvCoord, colToUv - min(screenAlpha + min(a2 * a1 + a3, 1.0), 1.0));\n    return col;\n    //return vec3(pow(clamp(pos.xy, 0.0, 1.0), vec2(2.2)), 0.0);\n}\n\nvec4 gizmoShade(vec2 mat, vec3 p)\n{\n    vec4 col = vec4(0.);\n\n    if(mat.y == MAT_CORNER) {\n        col = vec4(1.,0.,0., cornersAlpha);\n    } else if (mat.y == MAT_SCREENZ) {\n    \tcol = vec4(0.05, 0.05, 1., screenZAlpha);\n    } else if (mat.y == MAT_MARCHSPHERE) {\n        float alpha = clamp(sphereAnim - sphereID, 0.0, 1.0);\n        vec3 sc = mix(vec3(.0, .1, 3.), vec3(.02, 1., .02), float(sphereID == 0. || sphereID == 6.));\n    \tcol = vec4(sc, alpha * raySphereAlpha);\n    } else if (mat.y == MAT_MARCHROUTE) {\n        col = vec4(1., 0., 0., .9);\n    } else if (mat.y == MAT_RAYDIRECTION) {\n        col = vec4(1., 0., 0., .9);\n    } else if (mat.y == MAT_HITPOINT) {\n    \tcol = vec4(.02, 1., .02, raySphereAlpha);\n    }\n    return col;\n}\n\nvec4 radiusShade(vec2 mat, vec3 p)\n{\n    vec4 col = vec4(0.);\n\n    vec3 ray = vec3(0., 0., 1.);\n    vec2 d = vec2(10000.);\n\n    float t = 0.0;\n    for(int i=0; i<7; i++) {\n        vec3 pos = ray * t;\n        vec2 dd = sceneSpheres(pos);\n        d = vec2(sdSphere(p - pos, dd.x), MAT_MARCHSPHERE);\n        float alpha2 = step(radiusAnim, float(i) + 2.);\n        float alpha = clamp(radiusAnim - float(i) - 1., 0.0, 1.0);\n        \n        vec4 cirCol = mix(vec4(.0, 0.05, 0.1, 0.9), vec4(0.2, 1., 1.4, .6) , alpha2);\n        col = mix(col, cirCol, smoothstep(0.01, 0., d.x) * cirCol.a * alpha);\n        col = mix(col, vec4(0., 0., 0., 1.), smoothstep(0.02, 0., abs(d.x) - 0.01) * alpha);\n        t += dd.x;\n    }\n    col *= radiusAlpha;\n    return col;\n}\n\nfloat luminance(vec3 col)\n{\n    return dot(vec3(0.298912, 0.586611, 0.114478), col);\n}\n\nvec3 reinhard(vec3 col, float exposure, float white) {\n    col *= exposure;\n    white *= exposure;\n    float lum = luminance(col);\n    return (col * (lum / (white * white) + 1.0) / (lum + 1.0));\n}\n\nvec3 render(vec2 p) {\n    screenPos = vec3(p, 2.5);\n    vec3 ro = cameraPos;\n    vec3 ta = cameraTarget;\n    vec3 fo = normalize(ta - ro);\n    vec3 ri = normalize(cross(vec3(0.,1.,0.), fo));\n    vec3 up = normalize(cross(fo,ri));\n    mat3 cam = mat3(ri,up,fo);\n    vec3 ray = cam * normalize(screenPos);\n    float depth = 0.01;\n    vec2 mat;\n    vec3 col = vec3(0.);\n    \n    vec3 pos = ro;\n    sceneTrace(pos, ray, mat, depth, 100.);\n    \n    col = sceneShade(mat, pos, ray, depth, 100.);\n    \n    float sceneDepth = depth;\n    depth = 0.01;\n    pos = ro;\n    screenTrace(pos, ray, mat, depth, sceneDepth);\n    if (depth < sceneDepth) {\n        col = screenShade(mat, pos);\n    }\n    \n    float sceneAndScreenDepth = depth;\n    depth = 0.01;\n    pos = ro;\n    radiusTrace(pos, ray, mat, depth, sceneAndScreenDepth);\n    if (depth < sceneAndScreenDepth) {\n        vec4 radius = radiusShade(mat, pos);\n        col = mix(col, radius.rgb, radius.a);\n    }\n    \n    float sceneAndScreenAndGizmoDepth = sceneAndScreenDepth;\n    depth = 0.01;\n    pos = ro;\n    gizmoTrace(pos, ray, mat, depth, sceneAndScreenAndGizmoDepth);\n    if (depth < sceneAndScreenAndGizmoDepth) {\n        vec4 gizmo = gizmoShade(mat, pos);\n        col = mix(col, gizmo.rgb, gizmo.a);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    timeLine(mod(iTime, 41.));\n\n    vec2 p = (fragCoord * 2.0 - iResolution.xy)/min(iResolution.x, iResolution.y);\n    vec2 dp = 1. / iResolution.xy;\n\n    vec3 col = vec3(0.);\n    \n    \n    // AA\n    // https://www.shadertoy.com/view/Msl3Rr\n    for(int y = 0; y < 2; y++) {\n        for(int x = 0; x < 2; x++) {\n            vec2 off = vec2(float(x),float(y))/2.;\n            vec2 xy = (-iResolution.xy+2.0*(fragCoord+off)) / iResolution.y;\n        \tcol += render(xy)*0.25;\n        }\n    }\n    \n    col = reinhard(col, 1.0, 1000.0);\n    col = pow(col, vec3(1.0/2.2));\n    \n    //col = mix(col, vec3(mix(uv, p, uvToP), 0.), colToUv);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"3llGRf","date":"0","viewed":0,"name":"RayMarch-Concept","description":"RayMarch-Concept","likes":0,"published":"Private","tags":["raymarchconcept"]},"renderpass":[{"code":"const int STEPS=23;\n\nconst float smooth_pixels=3.;\nconst float thickness_pixels=0.1;\n    \nfloat dot2(vec2 p, vec2 q){\n\tp-=q;\n    return dot(p,p);\n}\nfloat circle(vec2 p,vec2 c,float r){\n\treturn length(p-c)-r;\n}\nfloat box( vec2 p,vec2 s, vec2 b){\n    p-=s;\n    vec2 d = abs(p) - b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat dist(vec2 p){\n\tfloat c0=circle(p,vec2(-1.,0.1),0.6);\n    float c1=circle(p,vec2(1,0.7),0.14);\n    float b=box(p,vec2(1.,-0.6),vec2(0.5,0.8));\n    return min(c1,min(c0,b));\n}\nfloat circ(vec2 p,vec2 c,float r,float w,float sf){\n\treturn smoothstep(w+sf,w,abs(length(p-c)-r+w+sf));\n}\nfloat cut(float x){\n\treturn clamp(x,0.,1.);\n}\nfloat line(vec2 p,vec2 p2,vec2 uv,float w,float sf){\n    vec2 n=uv-p;\n\tvec2 k=p2-p;\n\treturn smoothstep(w+sf,w,length(n-k*clamp(dot(n,k)/dot(k,k),0.,1.)));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    float sf=smooth_pixels/iResolution.y;\n    float w=thickness_pixels/iResolution.y;\n    \n    vec2 ro=vec2(-1.4,-0.9); //ray origin\n    vec2 rd=normalize(vec2(5,3));\n    \n    float t=mod(iTime*4.,float(2*STEPS));\n    \n\tvec3 col=vec3(0);\n    col+=0.0001/dot2(uv,ro)*vec3(-1,1,1);\n    col+=smoothstep(sf,0.,dist(uv));\n    \n    float d;\n    vec2 p=ro;\n    vec2 j;\n    for(int i=1;i<=STEPS;i++){\n\t\td=dist(p);\n    \tcol+=circ(uv,p,d*cut(t-float(i*2-2)),w,sf)*vec3(1,0,0);\n        j=rd*cut(t-float(i*2-1));\n        p+=j*d;\n    }\n    p-=rd*(w+sf);\n    col+=line(ro,p,uv,w,sf);\n    \n    \n    fragColor=vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"WllGRX","date":"0","viewed":0,"name":"RayMarch-Primitives","description":"RayMarch-Primitives","likes":0,"published":"Private","tags":["primitives"]},"renderpass":[{"code":"// The MIT License\n// Copyright © 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n    \n\n// A list of useful distance function to simple primitives. More info here:\n//\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n#define AA 1   // make this 2 or 3 for antialiasing\n\n\n//------------------------------------------------------------------\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n    \n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat dot2(in vec3 v ) {return dot(v,v);}\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdEquilateralTriangle(  in vec2 p )\n{\n    const float k = 1.73205;//sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    float d1 = q.z-h.y;\n    h.x *= 0.866025;\n    float d2 = sdEquilateralTriangle(p.xy/h.x)*h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\n// vertical\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\n\n#if 0\n// bound, not exact\nfloat sdOctahedron(vec3 p, float s ) \n{\n    p = abs(p);\n    return (p.x + p.y + p.z - s)*0.57735027;\n}\n#else\n// exacy distance\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    \n    float m = p.x + p.y + p.z - s;\n    \n\tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    \n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n#endif\n\n\n//------------------------------------------------------------------\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2( 1e10, 0.0 );\n\n    if( pos.x>-2.5 && pos.x<0.5 )\n    {\n    res = opU( res, vec2( sdRoundCone( pos-vec3(-1.0,0.20,-2.0), 0.2, 0.1, 0.3 ), 23.56 ) );\n    res = opU( res, vec2( sdTriPrism(  pos-vec3(-1.0,0.25,-1.0), vec2(0.25,0.05) ),43.5 ) );\n\tres = opU( res, vec2( sdHexPrism(  pos-vec3(-1.0,0.20, 1.0), vec2(0.25,0.05) ),17.0 ) );\n    res = opU( res, vec2( sdEllipsoid( pos-vec3(-1.0,0.30, 0.0), vec3(0.2, 0.25, 0.05) ), 43.17 ) );\n    }\n    if( pos.x>-1.5 && pos.x<1.5 )\n    {\n    res = opU( res, vec2( sdSphere(    pos-vec3( 0.0,0.25, 0.0), 0.25 ), 46.9 ) );\n\tres = opU( res, vec2( sdTorus(     pos-vec3( 0.0,0.25, 1.0), vec2(0.20,0.05) ), 25.0 ) );\n\tres = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.50,-1.0), vec3(0.8,0.6,0.3) ), 55.0 ) );\n    res = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.35,-2.0), 0.15, 0.2, 0.1 ), 13.67 ) );\n    }\n    if( pos.x>-0.5 && pos.x<2.5 )\n    {\n\tres = opU( res, vec2( sdOctahedron(pos-vec3( 1.0,0.15, 1.0), 0.35 ),37.0 ) );\n    res = opU( res, vec2( sdBox(       pos-vec3( 1.0,0.25, 0.0), vec3(0.25) ), 3.0 ) );\n    res = opU( res, vec2( sdCapsule(   pos-vec3( 1.0,0.00,-1.0),vec3(-0.1,0.1,-0.1), vec3(0.2,0.4,0.2), 0.1  ), 31.9 ) );\n\tres = opU( res, vec2( sdCylinder(  pos-vec3( 1.0,0.30,-2.0), vec2(0.1,0.2) ), 8.0 ) );\n    }\n    if( pos.x>0.5 )\n    {\n    res = opU( res, vec2( sdCylinder(   pos-vec3( 2.0,0.20,-2.0), vec3(0.1,-0.1,0.0), vec3(-0.1,0.3,0.1), 0.08), 31.2 ) );\n    res = opU( res, vec2( sdRoundCone(  pos-vec3( 2.0,0.20,-1.0), vec3(0.1,0.0,0.0), vec3(-0.1,0.3,0.1), 0.15, 0.05), 51.7 ) );\n\tres = opU( res, vec2( sdCone(       pos-vec3( 2.0,0.20, 0.0), vec3(0.1,0.0,0.0), vec3(-0.1,0.3,0.1), 0.15, 0.05), 46.1 ) );\n    }\n    \n\n\t//res = min( res, sdBox(pos-vec3(0.5,0.4,-0.5), vec3(2.0,0.41,2.0) ) );\n    return res;\n}\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nconst float maxHei = 0.8;\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    // raytrace floor plane\n    float tp1 = (0.0-ro.y)/rd.y;\n    if( tp1>0.0 )\n    {\n        tmax = min( tmax, tp1 );\n        res = vec2( tp1, 1.0 );\n    }\n    //else return res;\n    \n    // raymarch primitives   \n    vec2 tb = iBox( ro-vec3(0.5,0.4,-0.5), rd, vec3(2.0,0.41,2.0) );\n    if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)\n    {\n        tmin = max(tb.x,tmin);\n        tmax = min(tb.y,tmax);\n\n        float t = tmin;\n        for( int i=0; i<70 && t<tmax; i++ )\n        {\n            vec2 h = map( ro+rd*t );\n            if( abs(h.x)<(0.0001*t) )\n            { \n                res = vec2(t,h.y); \n                 break;\n            }\n            t += h.x;\n        }\n    }\n    \n    return res;\n}\n\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (maxHei-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n#if 1\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.45 + 0.35*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        if( m<1.5 )\n        {\n            \n            float f = checkersGradBox( 5.0*pos.xz );\n            col = 0.3 + f*vec3(0.1);\n        }\n\n        // lighting\n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.4, 0.7, -0.6) );\n        vec3  hal = normalize( lig-rd );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.2, 0.2, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        \n        dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n        dom *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n\n\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\n                    dif *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.40*dif*vec3(1.00,0.80,0.55);\n        lin += 0.20*amb*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.40*dom*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\t\tcol += 9.00*spe*vec3(1.00,0.90,0.70);\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 15.0 + iTime*2.0;\n\n    // camera\t\n    vec3 ro = vec3( 0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, -0.5+3.5*sin(0.1*time + 6.0*mo.x) );\n    vec3 ta = vec3( 0.5, -0.4, -0.5 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n        // render\t\n        vec3 col = render( ro, rd );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"wl33W2","date":"1577591248","viewed":6,"name":"Sphere UV","description":"球体UV坐标","likes":0,"published":"Public","tags":["math","uv","sphere"]},"renderpass":[{"code":"#define AA 2\n\n#define SpherePos vec3(0,0,0)\n#define SphereRadius 2.0\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos - SpherePos, SphereRadius),1));\n        \n    return res;\n}\n\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec2 getSphereUV(in vec3 pos)\n{\n    vec3 posLocal = pos - SpherePos;\n    //经纬角度\n    float longitudeAngle = atan(posLocal.x/posLocal.z)/3.1415926*180.0;\n    float latitudeAngle = acos(posLocal.y/SphereRadius)/3.1415926*180.0;\n    \n    return vec2(longitudeAngle,latitudeAngle);\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.3,0.8,1.0);\n    } else{\n        vec2 uv = getSphereUV(pos);\n        col = vec3(checkersGradBox(uv*0.1));\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(3.0 * cos(time + 6.0*mousePos.x), 2.0 + 2.0*mousePos.y, 3.0 * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0.0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"3tsGRX","date":"0","viewed":0,"name":"Text Render","description":"Text Render","likes":0,"published":"Private","tags":["textrender"]},"renderpass":[{"code":"float GlyphSDF( vec2 p, float glyph )\n{\n    p = abs( p.x - .5 ) > .5 || abs( p.y - .5 ) > .5 ? vec2( 0. ) : p;\n    return 2. * ( texture( iChannel0, p / 16. + fract( vec2( glyph, 15. - floor( glyph / 16. ) ) / 16. ) ).w - 127. / 255. );\n}\t\n\nvoid Text( inout vec3 color, vec2 p )\n{    \n    float glyphRatio = 2.0;\n    vec2 glyphScale = 6. * vec2( 1., glyphRatio );\n    vec2 t = floor( p / glyphScale );\n\n    uint v = 0u;\n\tv = t.y == 12. ? ( t.x < 4. ? 1936287828u : ( t.x < 8. ? 544434464u : ( t.x < 12. ? 1696624225u : ( t.x < 16. ? 1886216568u : ( t.x < 20. ? 1746953580u : ( t.x < 24. ? 1948284783u : ( t.x < 28. ? 1717903471u : ( t.x < 32. ? 1768122726u : ( t.x < 36. ? 1819569765u : ( t.x < 40. ? 1701978233u : ( t.x < 44. ? 1919247470u : 0u ) ) ) ) ) ) ) ) ) ) ) : v;\n\tv = t.y == 11. ? ( t.x < 4. ? 1735549292u : ( t.x < 8. ? 1818370149u : ( t.x < 12. ? 1936417647u : ( t.x < 16. ? 543584032u : ( t.x < 20. ? 1954047348u : ( t.x < 24. ? 1700012078u : ( t.x < 28. ? 1763734648u : ( t.x < 32. ? 1852121203u : ( t.x < 36. ? 1701080931u : ( t.x < 40. ? 1935745124u : ( t.x < 44. ? 1931501856u : 29797u ) ) ) ) ) ) ) ) ) ) ) : v;\n\tv = t.y == 10. ? ( t.x < 4. ? 1965057647u : ( t.x < 8. ? 1937010281u : ( t.x < 12. ? 540092448u : ( t.x < 16. ? 1918986339u : ( t.x < 20. ? 1954112047u : ( t.x < 24. ? 539828325u : ( t.x < 28. ? 1751326772u : ( t.x < 32. ? 796095073u : ( t.x < 36. ? 1953393013u : ( t.x < 40. ? 1310731817u : ( t.x < 44. ? 544503909u : 0u ) ) ) ) ) ) ) ) ) ) ) : v;\n\tv = t.y == 9. ? ( t.x < 4. ? 1701995379u : ( t.x < 8. ? 1663069797u : ( t.x < 12. ? 1685221231u : ( t.x < 16. ? 1918967923u : ( t.x < 20. ? 1868767333u : ( t.x < 24. ? 1919252078u : ( t.x < 28. ? 543450484u : ( t.x < 32. ? 1948282740u : ( t.x < 36. ? 543517801u : ( t.x < 40. ? 1629512809u : ( t.x < 44. ? 2122862u : 0u ) ) ) ) ) ) ) ) ) ) ) : v;\n\tv = t.y == 8. ? ( t.x < 4. ? 1918986339u : ( t.x < 8. ? 544434464u : ( t.x < 12. ? 1868784996u : ( t.x < 16. ? 778331492u : 0u ) ) ) ) : v;\n\tv = t.y == 7. ? 0u : v;\n\tv = t.y == 6. ? ( t.x < 4. ? 1853321028u : ( t.x < 8. ? 1701079411u : ( t.x < 12. ? 544434464u : ( t.x < 16. ? 1952540788u : ( t.x < 20. ? 1702257952u : ( t.x < 24. ? 1730181490u : ( t.x < 28. ? 1752201580u : ( t.x < 32. ? 1937075488u : ( t.x < 36. ? 1700929652u : ( t.x < 40. ? 1701344288u : ( t.x < 44. ? 1835103008u : 101u ) ) ) ) ) ) ) ) ) ) ) : v;\n\tv = t.y == 5. ? ( t.x < 4. ? 1702521203u : ( t.x < 8. ? 1969365036u : ( t.x < 12. ? 1852776564u : ( t.x < 16. ? 1701344288u : ( t.x < 20. ? 1752461088u : ( t.x < 24. ? 1746956901u : ( t.x < 28. ? 543452769u : ( t.x < 32. ? 1730176375u : ( t.x < 36. ? 1713402981u : ( t.x < 40. ? 544502625u : 0u ) ) ) ) ) ) ) ) ) ) : v;\n\tv = t.y == 4. ? ( t.x < 4. ? 1886220131u : ( t.x < 8. ? 1952541801u : ( t.x < 12. ? 544108393u : ( t.x < 16. ? 1701669236u : ( t.x < 20. ? 1851859059u : ( t.x < 24. ? 1919361124u : ( t.x < 28. ? 544498021u : ( t.x < 32. ? 1953396082u : ( t.x < 36. ? 6647145u : 0u ) ) ) ) ) ) ) ) ) : v;\n\tv = t.y == 3. ? ( t.x < 4. ? 1718773104u : ( t.x < 8. ? 1634562671u : ( t.x < 12. ? 543515502u : ( t.x < 16. ? 1852404520u : ( t.x < 20. ? 543517799u : ( t.x < 24. ? 544761204u : ( t.x < 28. ? 1668572518u : ( t.x < 32. ? 1768959848u : ( t.x < 36. ? 694969720u : ( t.x < 40. ? 46u : 0u ) ) ) ) ) ) ) ) ) ) : v;\n\tv = t.y == 2. ? 0u : v;\n\tv = t.y == 1. ? ( t.x < 4. ? 1868787269u : ( t.x < 8. ? 544367972u : ( t.x < 12. ? 1629516649u : ( t.x < 16. ? 1818845558u : ( t.x < 20. ? 1701601889u : ( t.x < 24. ? 544108320u : ( t.x < 28. ? 1215588679u : ( t.x < 32. ? 3826293u : 0u ) ) ) ) ) ) ) ) : v;\n\tv = t.y == 0. ? ( t.x < 4. ? 1886680168u : ( t.x < 8. ? 791624307u : ( t.x < 12. ? 1752459623u : ( t.x < 16. ? 1663984245u : ( t.x < 20. ? 1798270319u : ( t.x < 24. ? 1802658158u : ( t.x < 28. ? 1667856239u : ( t.x < 32. ? 1750282106u : ( t.x < 36. ? 1919247457u : ( t.x < 40. ? 1417244532u : ( t.x < 44. ? 7632997u : 0u ) ) ) ) ) ) ) ) ) ) ) : v;\n\tv = t.x >= 0. && t.x < 48. ? v : 0u;\n\n\tfloat c = float( ( v >> uint( 8. * t.x ) ) & 255u );\n    \n    p = ( p - t * glyphScale ) / glyphScale;\n    p.x = ( p.x - .5 ) / glyphRatio + .5;\n\n    float sdf = GlyphSDF( p, c );\n    if ( c != 0. )\n    {\n    \tcolor = mix( vec3( .2 ), color, smoothstep( -.04, +.04, sdf ) );\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = 2. * uv - 1.;\n\tp.x *= iResolution.x / iResolution.y;    \n    p = p * 100. - vec2( -150, -78 );\n    \n    vec3 color = vec3( mix( 1., .5, smoothstep( 0., 1., abs( .5 - uv.y ) ) ) );\n    Text( color, p );\n\tfragColor = vec4( color, 1. );\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"tt3GRj","date":"1577105511","viewed":29,"name":"Worley Cellular Noise 2D","description":"Cellular噪声","likes":1,"published":"Public","tags":["2d","noise","worley","cellular"]},"renderpass":[{"code":"float anim = 0.0;\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\n//在数组中随机取一个值，满足泊松分布，均值为2.5\nconst int Poisson_count[256]= int[](\n4,3,1,1,1,2,4,2,2,2,5,1,0,2,1,2,2,0,4,3,2,1,2,1,3,2,2,4,2,2,5,1,2,3,\n2,2,2,2,2,3,2,4,2,5,3,2,2,2,5,3,3,5,2,1,3,3,4,4,2,3,0,4,2,2,2,1,3,2,\n2,2,3,3,3,1,2,0,2,1,1,2,2,2,2,5,3,2,3,2,3,2,2,1,0,2,1,1,2,1,2,2,1,3,\n4,2,2,2,5,4,2,4,2,2,5,4,3,2,2,5,4,3,3,3,5,2,2,2,2,2,3,1,1,4,2,1,3,3,\n4,3,2,4,3,3,3,4,5,1,4,2,4,3,1,2,3,5,3,2,1,3,1,3,3,3,2,3,1,5,5,4,2,2,\n4,1,3,4,1,5,3,3,5,3,4,3,2,2,1,1,1,1,1,2,4,5,4,5,4,2,1,5,1,1,2,3,3,3,\n2,5,2,3,3,2,0,2,1,1,4,2,1,3,2,1,2,2,3,2,5,5,3,4,5,5,2,4,4,5,3,2,2,2,\n1,4,2,3,3,4,2,5,4,2,4,2,2,2,4,5,3,2);\n    \nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nvec2 noise22(in vec2 x){\n    vec3 p = vec3(x,0.5);\n    p.z += anim;\n    p *= m;\n    float fx = noise(p);\n    float fy = noise(p+vec3(1.23,4.56,7.89));\n    return vec2(fx,fy);\n}\n\n/*\n在cellX,cellY指定的晶格中采样，得到最近的四个距离\n*/\nvec4 AddSamples(int cellX, int cellY, vec2 at, vec4 oldFs, inout vec4 ids){\n    vec2 p = vec2(float(cellX),float(cellY));\n    vec2 seed = vec2(p.x*1.234+1234.0, p.y*5.678+5678.0);\n    float id = seed.x + seed.y;\n    //在晶格中产生若干个特征点，个数在泊松分布表中随机得到\n    int count = Poisson_count[int(fract(seed.x+seed.y)*256.0)];\n    for(int i = 0; i < count; i++){\n        vec2 diff = noise22(seed);\n        //偏移种子，用以产生下一个不同的偏移\n        seed.x = seed.x*1.366+0.123;\n        seed.y = seed.y*2.4745687+7.73246;\n        \n        vec2 featurePoint = p + diff;\n        \n        float d = length(featurePoint - at);\n        d*=d;\n        if(d<oldFs.x){\n            oldFs.yzw = oldFs.xyz;oldFs.x = d;\n            ids.yzw = ids.yzw;ids.x = id;\n        }else if(d<oldFs.y){\n            oldFs.zw = oldFs.yz;oldFs.y = d;\n            ids.zw = ids.yz;ids.y = id;\n        }else if(d<oldFs.z){\n            oldFs.w = oldFs.z;oldFs.z = d;\n            ids.w = ids.z;ids.z = id;\n        }else if(d<oldFs.w){\n            oldFs.w = d;\n            ids.w = id;\n        }\n        \n    }\n    return oldFs;\n}\n\n/*\n2d Worley细胞噪声\n输入：位置\n输出：从小到大排序的距离最近的四个特征点的距离\n*/\nvec4 cellularNoise2D(vec2 at, inout vec4 ids){\n    vec2 int_at = floor(at);\n    int int_at_x = int(int_at.x);\n    int int_at_y = int(int_at.y);\n    vec4 fs = vec4(9999999.0,9999999.0,9999999.0,9999999.0);\n    fs = AddSamples(int_at_x,int_at_y,at,fs,ids);\n    float dx1 = at.x - int_at.x;\n    float dy1 = at.y - int_at.y;\n    float dx2 = (1.0-dx1)*(1.0-dx1);\n    float dy2 = (1.0-dy1)*(1.0-dy1);\n    dx1 *= dx1;\n    dy1 *= dy1;\n    int max_order = 4;\n    //判断是否得到了最近的四个距离，如果是的话，不必在相邻晶格进行采样\n    if(dx1<fs[max_order-1])//左\n        fs = AddSamples(int_at_x-1,int_at_y,at,fs,ids);\n    if(dy1 < fs[max_order-1])//下\n        fs = AddSamples(int_at_x,int_at_y-1,at,fs,ids);\n    if(dx1+dy1 < fs[max_order-1])//左下\n        fs = AddSamples(int_at_x-1,int_at_y-1,at,fs,ids);\n    if(dx2 < fs[max_order-1])//右\n        fs = AddSamples(int_at_x+1,int_at_y,at,fs,ids);\n    if(dy2 < fs[max_order-1])//上\n        fs = AddSamples(int_at_x,int_at_y+1,at,fs,ids);\n    if(dx2+dy2 < fs[max_order-1])//右上\n        fs = AddSamples(int_at_x+1,int_at_y+1,at,fs,ids);\n    if(dx1+dy2 < fs[max_order-1])//左上\n        fs = AddSamples(int_at_x-1,int_at_y+1,at,fs,ids);\n    if(dx2+dy1 < fs[max_order-1])//右下\n        fs = AddSamples(int_at_x+1,int_at_y-1,at,fs,ids);\n    return fs;\n}\n\n\nvec4 fractalCellularNoise2D(vec2 at) {\n\tvec4 m = vec4(0.0, 0.0, 0.0, 0.0);\n\tfloat f = 1.0;\n\tfor (int i = 0; i < 5; i++) {\n        vec4 ids;\n\t\tm += cellularNoise2D(at*f,ids) / f;\n\t\tf *= 2.17;\n\t}\n\treturn m;\n}\n\nvec3 cellId2Color(float id)\n{\n\treturn texture(iChannel0,vec2(mod(id,64.)/64., mod(floor(id/64.),64.)/64.)).rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    anim = 0.5*(2.*iTime + .5*sin(1.*iTime+10.0));\n\n    vec2 p = fragCoord/iResolution.y;\n    vec2 at = p*4.0;\n    float anim2 = iTime*0.2;\n    float scanLineX = fract(anim2);\n    int demo = int(floor(mod(anim2,11.0)));//linear combination\n    float x = fragCoord.x/iResolution.x;\n    if(x > scanLineX){\n        demo = demo - 1;\n        if(demo<0)\n            demo = 10;\n    }\n    vec3 col = vec3(0.0,0.0,0.0);\n    \n        vec4 fs = fractalCellularNoise2D(at);fs = sqrt(fs);\n        col = vec3(fs.x);\n   \n    \n    col *= smoothstep(0.0,0.01,abs(x-scanLineX));\n    fragColor = vec4(col.xyz, 1.0);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"3ldGRl","date":"1577259203","viewed":39,"name":"Worley Cellular Noise 3D","description":"3d Cellular噪声","likes":1,"published":"Public","tags":["3d","noise","worley","cellular"]},"renderpass":[{"code":"#define AA 2\n\nfloat anim = 0.0;\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\n//在数组中随机取一个值，满足泊松分布，均值为2.5\nconst int Poisson_count[256]= int[](\n4,3,1,1,1,2,4,2,2,2,5,1,0,2,1,2,2,0,4,3,2,1,2,1,3,2,2,4,2,2,5,1,2,3,\n2,2,2,2,2,3,2,4,2,5,3,2,2,2,5,3,3,5,2,1,3,3,4,4,2,3,0,4,2,2,2,1,3,2,\n2,2,3,3,3,1,2,0,2,1,1,2,2,2,2,5,3,2,3,2,3,2,2,1,0,2,1,1,2,1,2,2,1,3,\n4,2,2,2,5,4,2,4,2,2,5,4,3,2,2,5,4,3,3,3,5,2,2,2,2,2,3,1,1,4,2,1,3,3,\n4,3,2,4,3,3,3,4,5,1,4,2,4,3,1,2,3,5,3,2,1,3,1,3,3,3,2,3,1,5,5,4,2,2,\n4,1,3,4,1,5,3,3,5,3,4,3,2,2,1,1,1,1,1,2,4,5,4,5,4,2,1,5,1,1,2,3,3,3,\n2,5,2,3,3,2,0,2,1,1,4,2,1,3,2,1,2,2,3,2,5,5,3,4,5,5,2,4,4,5,3,2,2,2,\n1,4,2,3,3,4,2,5,4,2,4,2,2,2,4,5,3,2);\n    \nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nvec3 noise33(in vec3 x){\n    vec3 p = x;\n    //p.z += anim;\n    //p *= m;\n    float fx = noise(p);\n    float fy = noise(p+vec3(1.23,4.56,7.89));\n    float fz = noise(p+vec3(1.23,4.56,7.89)*7.6543);\n    return vec3(fx,fy,fz);\n}\n\n/*\n在cellX,cellY指定的晶格中采样，得到最近的四个距离\n*/\nvec4 AddSamples(int cellX, int cellY, int cellZ, vec3 at, vec4 oldFs,inout vec4 ids){\n    vec3 p = vec3(float(cellX),float(cellY),float(cellZ));\n    vec3 seed = vec3(p.x*1.234+1234.0, p.y*5.678+5678.0, p.z*4.57+0.752);\n    float id = seed.x+seed.y+seed.z;\n    //在晶格中产生若干个特征点，个数在泊松分布表中随机得到\n    int count = Poisson_count[int(fract(seed.x+seed.y+seed.z)*256.0)];\n    for(int i = 0; i < count; i++){\n        vec3 diff = noise33(seed);\n        //偏移种子，用以产生下一个不同的偏移\n        seed.x = seed.x*1.366+0.123;\n        seed.y = seed.y*2.4745687+7.73246;\n        seed.z = seed.z*475.90235+87.7578;\n        \n        vec3 featurePoint = p + diff;\n        \n        float d = length(featurePoint - at);\n        d*=d;\n        if(d<oldFs.x){\n            oldFs.yzw = oldFs.xyz; oldFs.x = d;\n            ids.yzw = ids.xyz; ids.x = id;\n        }else if(d<oldFs.y){\n            oldFs.zw = oldFs.yz; oldFs.y = d;\n            ids.zw = ids.yz; ids.y = id;\n        }else if(d<oldFs.z){\n            oldFs.w = oldFs.z; oldFs.z = d;\n            ids.w = ids.z; ids.z = id;\n        }else if(d<oldFs.w){\n            oldFs.w = d;\n            ids.w = id;\n        }\n        \n    }\n    return oldFs;\n}\n\n/*\n3d Worley细胞噪声\n输入：位置\n输出：从小到大排序的距离最近的四个特征点的距离\n*/\nvec4 cellularNoise3D(vec3 at, inout vec4 ids){\n    vec3 int_at = floor(at);\n    int int_at_x = int(int_at.x);\n    int int_at_y = int(int_at.y);\n    int int_at_z = int(int_at.z);\n    vec4 fs = vec4(9999999.0,9999999.0,9999999.0,9999999.0);\n    fs = AddSamples(int_at_x,int_at_y,int_at_z,at,fs,ids);\n    float dx1 = at.x - int_at.x;\n    float dy1 = at.y - int_at.y;\n    float dz1 = at.z - int_at.z;\n    float dx2 = (1.0-dx1)*(1.0-dx1);\n    float dy2 = (1.0-dy1)*(1.0-dy1);\n    float dz2 = (1.0-dz1)*(1.0-dz1);\n    dx1 *= dx1;\n    dy1 *= dy1;\n    dz1 *= dz1;\n    int max_order = 4;\n    //判断是否得到了最近的四个距离，如果是的话，不必在相邻晶格进行采样\n    //z = +1\n    if(dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y,  int_at_z+1,at,fs,ids);\n    if(dx1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y,  int_at_z+1,at,fs,ids);\n    if(dx2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y,  int_at_z+1,at,fs,ids);\n    if(dy1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y-1,int_at_z+1,at,fs,ids);\n    if(dx1+dy1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y-1,int_at_z+1,at,fs,ids);\n    if(dx2+dy1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y-1,int_at_z+1,at,fs,ids);\n    if(dy2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y+1,int_at_z+1,at,fs,ids);\n    if(dx1+dy2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y+1,int_at_z+1,at,fs,ids);\n    if(dx2+dy2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y+1,int_at_z+1,at,fs,ids);\n    //z = -1\n    if(dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y,  int_at_z-1,at,fs,ids);\n    if(dx1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y,  int_at_z-1,at,fs,ids);\n    if(dx2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y,  int_at_z-1,at,fs,ids);\n    if(dy1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y-1,int_at_z-1,at,fs,ids);\n    if(dx1+dy1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y-1,int_at_z-1,at,fs,ids);\n    if(dx2+dy1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y-1,int_at_z-1,at,fs,ids);\n    if(dy2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y+1,int_at_z-1,at,fs,ids);\n    if(dx1+dy2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y+1,int_at_z-1,at,fs,ids);\n    if(dx2+dy2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y+1,int_at_z-1,at,fs,ids);\n    //z = 0\n    if(dx1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y,  int_at_z,at,fs,ids);\n    if(dx2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y,  int_at_z,at,fs,ids);\n    if(dy1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y-1,int_at_z,at,fs,ids);\n    if(dx1+dy1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y-1,int_at_z,at,fs,ids);\n    if(dx2+dy1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y-1,int_at_z,at,fs,ids);\n    if(dy2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y+1,int_at_z,at,fs,ids);\n    if(dx1+dy2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y+1,int_at_z,at,fs,ids);\n    if(dx2+dy2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y+1,int_at_z,at,fs,ids);\n    return fs;\n}\n\nvec4 fractalCellularNoise3D(vec3 at) {\n\tvec4 m = vec4(0.0, 0.0, 0.0, 0.0);\n\tfloat f = 1.0;\n\tfor (int i = 0; i < 4; i++) {\n        vec4 ids;\n\t\tm += cellularNoise3D(at*f,ids) / f;\n\t\tf *= 2.17;\n\t}\n\treturn m;\n}\n\nvec3 cellId2Color(float id)\n{\n\treturn texture(iChannel0,vec2(mod(id,64.)/64., mod(floor(id/64.),64.)/64.)).rgb;\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos + vec3(0,0,0), 2.0),1));\n    \n    //res = opU(res, vec2(sdBox(pos+vec3(-1.5,0,0),vec3(1.0,0.3,1.0)),1));\n    \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.8,0.8,1.0);\n    } else{\n        vec4 ids;\n         vec4 fs = cellularNoise3D(pos*4.0, ids);// fractalCellularNoise3D(pos*4.0);\n         fs = sqrt(fs);\n         float c = fs.x*(0.95*fs.y-fs.x); \n\t\t col = (c<0.0)? vec3(-c) : (1.0 - c)*cellId2Color(ids.x);\n         //col = vec3(fs.y);\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    anim = 0.5*(2.*iTime + .5*sin(1.*iTime+10.0));\n    \n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(3.0 * cos(time + 6.0*mousePos.x), 2.0 + 2.0*mousePos.y, 3.0 * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0.0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"WstSW8","date":"1571901597","viewed":27,"name":"zilong","description":"zilong","likes":0,"published":"Private","tags":["zilong"]},"renderpass":[{"code":"\n\nfloat hash( float n )\n{\n    return fract(sin(n)*158.5453123);\n}\n\nfloat noise( in float x )\n{\n    float p = floor(x);\n    float f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    return mix( hash(p+0.0), hash(p+1.0),f);\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*157.0;\n\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n               mix( hash(n+157.0), hash(n+158.0),f.x),f.y);\n}\n\nconst mat2 m2 = mat2( 0.80, -0.60, 0.60, 0.80 );\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n\n    f += 0.5000*noise( p ); p = m2*p*2.02;\n    f += 0.2500*noise( p ); p = m2*p*2.03;\n    f += 0.1250*noise( p ); p = m2*p*2.01;\n    f += 0.0625*noise( p );\n\n    return f/0.9375;\n}\n\nvec3 texturize( sampler2D sa, vec3 p, vec3 n )\n{\n\tvec3 x = texture( sa, p.yz ).xyz;\n\tvec3 y = texture( sa, p.zx ).xyz;\n\tvec3 z = texture( sa, p.xy ).xyz;\n\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\n\n//----------------------------------------------------------------\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nvec2 sdSegment( vec3 a, vec3 b, vec3 p )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa - ba*h ), h );\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\n// trick by klems\n#define ZERO (min(iFrame,0))\n\n//----------------------------------------------------------------\n\nvec2 map( vec3 p )\n{\n\tp.y -= 1.8;\n    \n\t//p.x = abs(p.x);\n\n    //body\n\tvec3 q = p;\n    \n\t//q.y -= 0.3*pow(1.0-length(p.xz),1.0)*smoothstep(0.0, 0.2, p.y);\n\t//q.y *= 1.05;\n\t//q.z *= 1.0 + 0.1*smoothstep( 0.0, 0.5, q.z )*smoothstep( -0.5, 0.5, p.y );\n    //float dd = length( (p - vec3(0.0,0.65,0.8))*vec3(1.0,0.75,1.0) );\n\t/*\n    float am = clamp( 4.0*abs(p.y-0.45), 0.0, 1.0 );\n\tfloat fo = -0.03*(1.0-smoothstep( 0.0, 0.04*am, abs(dd-0.42) ))*am;\n    float dd2 = length( (p - vec3(0.0,0.65,0.8))*vec3(1.0,0.25,1.0) );\n\tfloat am2 = clamp( 1.5*(p.y-0.45), 0.0, 1.0 );\n\tfloat fo2 = -0.085*(1.0-smoothstep( 0.0, 0.08*am2, abs(dd2-0.42) ))*am2;\n    q.y += -0.05+0.05*length(q.x);\n\t*/\n\t//float d1 = length( q ) - 0.9;//+ fo + fo2;\n    q.y *= 1.3;\n    float d1 = sdRoundCone( q, 0.8, 0.6, 0.3);\n    vec2 res = vec2( d1, 1.0 );\n    \n    vec2 h;float d2;\n    /*\n\t// arms\n\tvec2 h = sdSegment( vec3(.83,0.15,0.0), vec3(1.02,-0.6,-.1), p );\n\tfloat d2 = h.x - 0.07;\n\tres.x = smin( res.x, d2, 0.03 );\n\th = sdSegment( vec3(1.02,-0.6,-.1), vec3(0.95,-1.2,0.1), p );\n\td2 = h.x - 0.07 + h.y*0.02;\n\tres.x = smin( res.x, d2, 0.06 );\n\t*/\n    /*\n\t// hands\n\tif( p.y<-1.0 )\n\t{\n    float fa = sin(3.0*iTime);\n\th = sdSegment( vec3(0.95,-1.2,0.1), vec3(0.97,-1.5,0.0), p );\n\td2 = h.x - 0.03;\n\tres.x = smin( res.x, d2, 0.01 );\n\th = sdSegment( vec3(0.97,-1.5,0.0), vec3(0.95,-1.7,0.0)-0.01*fa, p );\n\td2 = h.x - 0.03 + 0.01*h.y;\n\tres.x = smin( res.x, d2, 0.02 );\n\th = sdSegment( vec3(0.95,-1.2,0.1), vec3(1.05,-1.5,0.1), p );\n\td2 = h.x - 0.03;\n\tres.x = smin( res.x, d2, 0.02 );\n\th = sdSegment( vec3(1.05,-1.5,0.1), vec3(1.0,-1.75,0.1)-0.01*fa, p );\n\td2 = h.x - 0.03 + 0.01*h.y;\n\tres.x = smin( res.x, d2, 0.02 );\n\th = sdSegment( vec3(0.95,-1.2,0.1), vec3(0.98,-1.5,0.2), p );\n\td2 = h.x - 0.03;\n\tres.x = smin( res.x, d2, 0.03 );\n\th = sdSegment( vec3(0.98,-1.5,0.2), vec3(0.95,-1.7,0.15)-0.01*fa, p );\n\td2 = h.x - 0.03 + 0.01*h.y;\n\tres.x = smin( res.x, d2, 0.03 );\n\th = sdSegment( vec3(0.95,-1.2,0.1), vec3(0.85,-1.4,0.2), p );\n\td2 = h.x - 0.04 + 0.01*h.y;\n\tres.x = smin( res.x, d2, 0.05 );\n\th = sdSegment( vec3(0.85,-1.4,0.2), vec3(0.85,-1.63,0.15)+0.01*fa, p );\n\td2 = h.x - 0.03 + 0.01*h.y;\n\tres.x = smin( res.x, d2, 0.03 );\n\t}\n\t*/\n    //x轴对称绘制\n    vec3 tp = p;\n    tp.x = abs(p.x);\n\t// legs\n\th = sdSegment( vec3(0.2,-0.5,0.0), vec3(0.2,-1.0,0.0), tp );\n\td2 = h.x - 0.05 - h.y*0.02;\n    if( d2<res.x ) res = vec2( d2, 2.0);\n    // feet\n\th = sdSegment( vec3(0.2,-1.0,0.0), vec3(0.4,-1.0,0.0), tp);\n\td2 = h.x - 0.05 - 0.03*h.y;\n\tif( d2<res.x ) res = vec2( d2, 2.0);\n\t//arm\n\th = sdSegment( vec3(0.7,0.2,0.0), vec3(0.8,0.3,0.0), tp);\n\td2 = h.x - 0.10 + 0.03*h.y;\n\tif( d2<res.x ) res = vec2( d2, 2.0);\n    h = sdSegment( vec3(0.8,0.3,0.0), vec3(1.4,0.5,0.0), tp);\n\td2 = h.x - 0.10 + 0.04*h.y;\n\tif( d2<res.x ) res = vec2( d2, 2.0);\n    \n\t// horns\n    h = sdSegment( vec3(0.20,0.7,0.0), vec3(0.18,1.0,0.0), tp);\n\td2 = h.x - 0.09 + 0.02*h.y;\n\tif( d2<res.x ) res = vec2( d2, 3.0 );\n    h = sdSegment( vec3(0.18,1.0,0.0), vec3(0.14,1.4,0.0), tp);\n\td2 = h.x - 0.09 + 0.02*h.y;\n\tif( d2<res.x ) res = vec2( d2, 3.0 );\n    h = sdSegment( vec3(0.18,1.0,0.0), vec3(0.35,1.2,0.0),tp);\n\td2 = h.x - 0.09 + 0.02*h.y;\n\tif( d2<res.x ) res = vec2( d2, 3.0 );\n    \n    /*\n\tvec3 hp = tp - vec3(0.25,0.7,0.0);\n    hp.xy = mat2(0.6,0.8,-0.8,0.6)*hp.xy;\n    hp.x += 0.8*hp.y*hp.y;\n    float d4 = sdEllipsoid( hp, vec3(0.13,0.5,0.16) );\n\t//d4 *= 0.9;\n\tif( d4<res.x ) res = vec2( d4, 3.0 );\n    */\n    \n    \n\t// eyes\n\tfloat d3 = length( (tp - vec3(0.2,0.25,0.7))*vec3(1.0,1.0,1.0) ) - 0.1;\n\tif( d3<res.x ) res = vec2( d3, 2.0);\n\n    \n    \n\t// mouth\n    \n\tfloat mo = length( (q-vec3(0.0,-0.2,1.0))*vec3(0.6,1.6,0.25)/1.2 ) -0.3/1.2;\n\tfloat of = 0.1*pow(smoothstep( 0.0, 0.2, abs(p.x-0.3) ),0.5);\n\tmo = max( mo, -q.y-0.35-of );\n\n\tfloat li = smoothstep( 0.0, 0.05, mo+0.02 ) - smoothstep( 0.05, 0.10, mo+0.02 );\n\tres.x -= 0.03*li*clamp( (-q.y-0.4)*10.0, 0.0, 1.0 );\n\t\n\tif( -mo > res.x )\n\t\tres = vec2( -mo, 4.0 );\n    \n    res.x += 0.01*(smoothstep( 0.0, 0.05, mo+0.062 ) - smoothstep( 0.05, 0.10, mo+0.062 ));\n    \n\treturn vec2(res.x*0.8,res.y);\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n#if 0    \n    vec3 eps = vec3(0.002,0.0,0.0);\n\treturn normalize( vec3(\n           map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n           map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n           map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );\n#else\n    // inspired by klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.002*e).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nvec3 intersect( in vec3 ro, in vec3 rd )\n{\n    float m = -1.0;\n\tfloat mint = 10.0;\n\n    // plane\t\n\tfloat tf = (0.0-ro.y)/rd.y;\n\tif( tf>0.0 ) { mint = tf; m = 0.0; }\n\t\n\t// mike\n\tfloat maxd = min(5.0,mint);\n\tfloat precis = 0.001;\n    float t = 0.0;\n\tfloat d = 0.0;\n    for( int i=ZERO; i<128; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        float h = res.x;\n\t\td = res.y;\n        if( h<precis||t>maxd ) break;\n        t += h;\n    }\n\n    if( t<maxd && t<mint )\n\t{\n\t\tmint = t;\n\t\tm = d;\n\t}\n\n    return vec3( mint, m, m );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<50; i++ )\n    {\n        float h = map(ro + rd*t).x;\n        res = min( res, smoothstep(0.0,1.0,k*h/t) );\n\t\tt += clamp( h, 0.01, 0.25 );\n\t\tif( res<0.005 || t>10.0 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\n\nvec3 lig = normalize(vec3(1.0,0.7,0.9));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 m = vec2(0.5);\n\t//if( iMouse.z>0.0 ) m = iMouse.xy/iResolution.xy;\n    \n\t#ifdef STEREO\n\tfloat eyeID = mod(fragCoord.x + mod(fragCoord.y,2.0),2.0);\n    #endif\n\n\n\t\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n\t\n\tfloat an = sin(-0.25 + 0.31416*iTime) - 6.2831*(m.x-0.5);\n\n\tvec3 ro = vec3(4.5*sin(an),1.5,4.5*cos(an));\n    vec3 ta = vec3(0.0,1.5,0.0);\n\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tvec3 col = vec3(1.0);\n\n\t// raymarch\n    vec3 tmat = intersect(ro,rd);\n    if( tmat.z>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + tmat.x*rd;\n        vec3 nor = calcNormal(pos);\n\t\tvec3 ref = reflect( rd, nor );\n\n        // materials\n\t\tvec4 mate = vec4(0.0);\n\t\tvec2 mate2 = vec2(1.0,1.0);\n\t\tif( tmat.z<0.5 )\n\t\t{\n\t\t\tnor = vec3(0.0,1.0,0.0);\n\t\t    ref = reflect( rd, nor );\n\t\t\tmate.xyz = vec3(1.0);\n            mate2.y = 1.0 - 0.9*(2.0/(2.0+dot(pos.xz,pos.xz)));\n\t\t}\n\t\telse if( tmat.z<1.5 )//mat id == 1\n\t\t{\n            mate2.x = 4.0;\n\t\t\tmate = vec4(0.5,0.0,0.5,0.8);//紫色基调\n\n            float f = texturize( iChannel0, 0.15*pos, nor ).x * texturize( iChannel0, 0.2*0.25*pos, nor ).x;\n\t\t\tmate.xyz = mix( 0.8*mate.xyz, vec3(0.3,0.0,0.4), f );\n\n\t\t\tf = texturize( iChannel0, pos, nor ).x * texturize( iChannel0, 0.25*pos, nor ).x;\n\t\t\tf = f*f;\n\t\t    mate.xyz = mix( mate.xyz, vec3(0.3,0.0,0.4), 0.6*f );\n\n\t\t\tvec3 bnor = -1.0+2.0*texturize( iChannel0, 4.0*pos, nor );\n\t\t\tnor = normalize( nor + 0.15*bnor );\n\t\t\t\n\t\t\tmate.xyz *= 0.7;\n\n\t\t}\n\t\telse if( tmat.z<2.5 )//mat id == 2 \n\t\t{\n\t\t\tmate2.x = 4.0;\n\t\t\tmate = vec4(0.1,0.1,0.1,0.0);\n\n            float f = texturize( iChannel0, 0.15*pos, nor ).x * texturize( iChannel0, 0.2*0.25*pos, nor ).x;\n\t\t\tmate.xyz = mix( 0.8*mate.xyz, vec3(0.01,0.01,0.01), f );\n\n\t\t\tf = texturize( iChannel0, pos, nor ).x * texturize( iChannel0, 0.25*pos, nor ).x;\n\t\t\tf = f*f;\n\t\t    mate.xyz = mix( mate.xyz, vec3(0.01,0.01,0.01), 0.6*f );\n\n\t\t\tvec3 bnor = -1.0+2.0*texturize( iChannel0, 4.0*pos, nor );\n\t\t\tnor = normalize( nor + 0.15*bnor );\n\t\t\t\n\t\t\tmate.xyz *= 0.7;\n\t\t}\n\t\telse if( tmat.z<3.5 )\n\t\t{\n\t\t\tmate = 0.8*vec4(0.85,0.7,0.6,0.0);\n            mate2.x = 0.0;\n\n\t\t\tfloat f = smoothstep( 0.0, 0.1, 0.5*abs(pos.x)+pos.y-3.02 );\n\t\t\tmate.xyz *= 1.0 - 0.8*vec3( f );\n\t\t\t\n\t\t\tmate.xyz *= 0.2 + 0.8*smoothstep( 0.0, 1.0, texturize( iChannel0, 0.1*2.1*pos*vec3(4.0,0.1,4.0), nor ).x );\n\t\t}\n\t\telse if( tmat.z<4.5 )//id == 4内部材质\n\t\t{\n\t\t\tfloat z = smoothstep( 0.0, 2.0, pos.z+0.5 );\n\t\t\tmate = 0.5*vec4(1.0,1.0,1.0,1.0);\n\t\t\tmate.x += 0.1*(1.0-z);\n\t\t\tmate2.y = z;\n\t\t}\n\n\n\t\t// lighting\n\t\tfloat occ = (0.5 + 0.5*nor.y)*mate2.y;\n        float amb = 0.5;\n\t\tfloat bou = clamp(-nor.y,0.0,1.0);\n\t\tfloat dif = max(dot(nor,lig),0.0);\n        float bac = max(0.3 + 0.7*dot(nor,-lig),0.0);\n\t\tfloat sha = 0.0; if( dif>0.01 ) sha=softshadow( pos+0.01*nor, lig, 0.001, 32.0 );\n        float fre = pow( clamp( 1.0 + dot(nor,rd), 0.0, 1.0 ), 2.0 );\n        vec3  hal = normalize(lig-rd);\n        float spe = max(pow( clamp( dot(nor,hal), 0.0, 1.0), mate2.x*4.0 ),0.0 );\n\t\t\n\t\t// lights\n\t\tvec3 lin = vec3(0.0);\n        lin += 2.0*dif*vec3(1.00,1.00,1.00)*pow(vec3(sha),vec3(1.0,1.2,1.5));\n\t\tlin += 1.0*amb*vec3(0.30,0.30,0.30)*occ;\n\t\tlin += 2.0*bou*vec3(0.40,0.40,0.40)*mate2.y;\n\t\tlin += 4.0*bac*vec3(0.40,0.30,0.25)*occ;\n        lin += 1.0*fre*vec3(1.00,1.00,1.00)*2.0*mate.w*(0.5+0.5*dif*sha)*occ;\n\n\t\tcol = mate.xyz*lin;\n\t\tcol += 4.0*spe*vec3(2.0)*mate.w*dif*sha*(0.04+0.96*pow(clamp(1.0+dot(hal,rd),0.0,1.0),5.0));\n\t}\n\n\n\t//-----------------------------------------------------\n\t// postprocessing\n    //-----------------------------------------------------\n    // gamma\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.45) );\n\n\t// vigneting\n    col *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.25 );\n   \n    fragColor = vec4( col, 1.0 );\n}\n","name":"Image","description":"","type":"image"}]}]}